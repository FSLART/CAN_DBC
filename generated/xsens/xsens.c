/**
 * @file xsens.c
 *
 * @brief This source file was generated by cantools version 40.2.3 Sat Jul 26 01:58:43 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <string.h>

#include "xsens.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int xsens_error_pack(
    uint8_t *dst_p,
    const struct xsens_error_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    return (1);
}

int xsens_error_unpack(
    struct xsens_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 1u) {
        return (-EINVAL);
    }

    return (0);
}

int xsens_error_init(struct xsens_error_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_error_t));

    return 0;
}

int xsens_warning_pack(
    uint8_t *dst_p,
    const struct xsens_warning_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->warning_code, 0u, 0xffu);

    return (1);
}

int xsens_warning_unpack(
    struct xsens_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->warning_code = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int xsens_warning_init(struct xsens_warning_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_warning_t));

    return 0;
}

uint8_t xsens_warning_warning_code_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_warning_warning_code_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_warning_warning_code_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int xsens_sample_time_pack(
    uint8_t *dst_p,
    const struct xsens_sample_time_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_right_shift_u32(src_p->timestamp, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->timestamp, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->timestamp, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->timestamp, 0u, 0xffu);

    return (4);
}

int xsens_sample_time_unpack(
    struct xsens_sample_time_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->timestamp = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->timestamp |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->timestamp |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->timestamp |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);

    return (0);
}

int xsens_sample_time_init(struct xsens_sample_time_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_sample_time_t));

    return 0;
}

uint32_t xsens_sample_time_timestamp_encode(double value)
{
    return (uint32_t)(value);
}

double xsens_sample_time_timestamp_decode(uint32_t value)
{
    return ((double)value);
}

bool xsens_sample_time_timestamp_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int xsens_group_counter_pack(
    uint8_t *dst_p,
    const struct xsens_group_counter_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_right_shift_u16(src_p->counter, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->counter, 0u, 0xffu);

    return (2);
}

int xsens_group_counter_unpack(
    struct xsens_group_counter_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->counter = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->counter |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);

    return (0);
}

int xsens_group_counter_init(struct xsens_group_counter_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_group_counter_t));

    return 0;
}

uint16_t xsens_group_counter_counter_encode(double value)
{
    return (uint16_t)(value);
}

double xsens_group_counter_counter_decode(uint16_t value)
{
    return ((double)value);
}

bool xsens_group_counter_counter_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int xsens_status_word_pack(
    uint8_t *dst_p,
    const struct xsens_status_word_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->have_gnss_time_pulse, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->rtk_status, 3u, 0x18u);
    dst_p[0] |= pack_right_shift_u8(src_p->filter_mode, 1u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->filter_mode, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->clip_mag_z, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->retransmitted, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->clipping_detected, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->interpolated, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->sync_in, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->sync_out, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_x, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_y, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_z, 2u, 0x04u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_x, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_y, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_z, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_mag_x, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_mag_y, 7u, 0x80u);
    dst_p[3] |= pack_left_shift_u8(src_p->self_test_ok, 0u, 0x01u);
    dst_p[3] |= pack_left_shift_u8(src_p->orientation_valid, 1u, 0x02u);
    dst_p[3] |= pack_left_shift_u8(src_p->gps_valid, 2u, 0x04u);
    dst_p[3] |= pack_left_shift_u8(src_p->no_rotation, 3u, 0x18u);
    dst_p[3] |= pack_left_shift_u8(src_p->representative_motion, 5u, 0x20u);
    dst_p[3] |= pack_left_shift_u8(src_p->external_clock_synced, 6u, 0x40u);

    return (4);
}

int xsens_status_word_unpack(
    struct xsens_status_word_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->have_gnss_time_pulse = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->rtk_status = unpack_right_shift_u8(src_p[0], 3u, 0x18u);
    dst_p->filter_mode = unpack_left_shift_u8(src_p[0], 1u, 0x03u);
    dst_p->filter_mode |= unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->clip_mag_z = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->retransmitted = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->clipping_detected = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->interpolated = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->sync_in = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->sync_out = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->clip_acc_x = unpack_right_shift_u8(src_p[2], 0u, 0x01u);
    dst_p->clip_acc_y = unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->clip_acc_z = unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->clip_gyr_x = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->clip_gyr_y = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->clip_gyr_z = unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->clip_mag_x = unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->clip_mag_y = unpack_right_shift_u8(src_p[2], 7u, 0x80u);
    dst_p->self_test_ok = unpack_right_shift_u8(src_p[3], 0u, 0x01u);
    dst_p->orientation_valid = unpack_right_shift_u8(src_p[3], 1u, 0x02u);
    dst_p->gps_valid = unpack_right_shift_u8(src_p[3], 2u, 0x04u);
    dst_p->no_rotation = unpack_right_shift_u8(src_p[3], 3u, 0x18u);
    dst_p->representative_motion = unpack_right_shift_u8(src_p[3], 5u, 0x20u);
    dst_p->external_clock_synced = unpack_right_shift_u8(src_p[3], 6u, 0x40u);

    return (0);
}

int xsens_status_word_init(struct xsens_status_word_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_status_word_t));

    return 0;
}

uint8_t xsens_status_word_have_gnss_time_pulse_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_have_gnss_time_pulse_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_have_gnss_time_pulse_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_rtk_status_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_rtk_status_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_rtk_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_filter_mode_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_filter_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_filter_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_mag_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_mag_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_mag_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_retransmitted_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_retransmitted_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_retransmitted_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clipping_detected_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clipping_detected_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clipping_detected_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_interpolated_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_interpolated_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_interpolated_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_sync_in_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_sync_in_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_sync_in_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_sync_out_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_sync_out_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_sync_out_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_acc_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_acc_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_acc_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_acc_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_acc_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_acc_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_acc_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_acc_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_acc_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_gyr_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_gyr_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_gyr_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_gyr_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_gyr_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_gyr_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_gyr_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_gyr_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_gyr_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_mag_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_mag_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_mag_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_clip_mag_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_clip_mag_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_clip_mag_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_self_test_ok_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_self_test_ok_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_self_test_ok_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_orientation_valid_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_orientation_valid_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_orientation_valid_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_gps_valid_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_gps_valid_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_gps_valid_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_no_rotation_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_no_rotation_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_no_rotation_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t xsens_status_word_representative_motion_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_representative_motion_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_representative_motion_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_status_word_external_clock_synced_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_status_word_external_clock_synced_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_status_word_external_clock_synced_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int xsens_quaternion_pack(
    uint8_t *dst_p,
    const struct xsens_quaternion_t *src_p,
    size_t size)
{
    uint16_t q0;
    uint16_t q1;
    uint16_t q2;
    uint16_t q3;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    q0 = (uint16_t)src_p->q0;
    dst_p[0] |= pack_right_shift_u16(q0, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(q0, 0u, 0xffu);
    q1 = (uint16_t)src_p->q1;
    dst_p[2] |= pack_right_shift_u16(q1, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(q1, 0u, 0xffu);
    q2 = (uint16_t)src_p->q2;
    dst_p[4] |= pack_right_shift_u16(q2, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(q2, 0u, 0xffu);
    q3 = (uint16_t)src_p->q3;
    dst_p[6] |= pack_right_shift_u16(q3, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(q3, 0u, 0xffu);

    return (8);
}

int xsens_quaternion_unpack(
    struct xsens_quaternion_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t q0;
    uint16_t q1;
    uint16_t q2;
    uint16_t q3;

    if (size < 8u) {
        return (-EINVAL);
    }

    q0 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    q0 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->q0 = (int16_t)q0;
    q1 = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    q1 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->q1 = (int16_t)q1;
    q2 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    q2 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->q2 = (int16_t)q2;
    q3 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    q3 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->q3 = (int16_t)q3;

    return (0);
}

int xsens_quaternion_init(struct xsens_quaternion_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_quaternion_t));

    return 0;
}

int16_t xsens_quaternion_q0_encode(double value)
{
    return (int16_t)(value / 3.0517578125e-05);
}

double xsens_quaternion_q0_decode(int16_t value)
{
    return ((double)value * 3.0517578125e-05);
}

bool xsens_quaternion_q0_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_quaternion_q1_encode(double value)
{
    return (int16_t)(value / 3.0517578125e-05);
}

double xsens_quaternion_q1_decode(int16_t value)
{
    return ((double)value * 3.0517578125e-05);
}

bool xsens_quaternion_q1_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_quaternion_q2_encode(double value)
{
    return (int16_t)(value / 3.0517578125e-05);
}

double xsens_quaternion_q2_decode(int16_t value)
{
    return ((double)value * 3.0517578125e-05);
}

bool xsens_quaternion_q2_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_quaternion_q3_encode(double value)
{
    return (int16_t)(value / 3.0517578125e-05);
}

double xsens_quaternion_q3_decode(int16_t value)
{
    return ((double)value * 3.0517578125e-05);
}

bool xsens_quaternion_q3_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_delta_v_pack(
    uint8_t *dst_p,
    const struct xsens_delta_v_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_right_shift_u16(x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(x, 0u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_right_shift_u16(y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(y, 0u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_right_shift_u16(z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->exponent, 0u, 0xffu);

    return (7);
}

int xsens_delta_v_unpack(
    struct xsens_delta_v_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 7u) {
        return (-EINVAL);
    }

    x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->z = (int16_t)z;
    dst_p->exponent = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

int xsens_delta_v_init(struct xsens_delta_v_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_delta_v_t));

    return 0;
}

int16_t xsens_delta_v_x_encode(double value)
{
    return (int16_t)(value / 7.6293945313e-06);
}

double xsens_delta_v_x_decode(int16_t value)
{
    return ((double)value * 7.6293945313e-06);
}

bool xsens_delta_v_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_delta_v_y_encode(double value)
{
    return (int16_t)(value / 7.6293945313e-06);
}

double xsens_delta_v_y_decode(int16_t value)
{
    return ((double)value * 7.6293945313e-06);
}

bool xsens_delta_v_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_delta_v_z_encode(double value)
{
    return (int16_t)(value / 7.6293945313e-06);
}

double xsens_delta_v_z_decode(int16_t value)
{
    return ((double)value * 7.6293945313e-06);
}

bool xsens_delta_v_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t xsens_delta_v_exponent_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_delta_v_exponent_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_delta_v_exponent_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int xsens_rate_of_turn_pack(
    uint8_t *dst_p,
    const struct xsens_rate_of_turn_t *src_p,
    size_t size)
{
    uint16_t gyr_x;
    uint16_t gyr_y;
    uint16_t gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    gyr_x = (uint16_t)src_p->gyr_x;
    dst_p[0] |= pack_right_shift_u16(gyr_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(gyr_x, 0u, 0xffu);
    gyr_y = (uint16_t)src_p->gyr_y;
    dst_p[2] |= pack_right_shift_u16(gyr_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(gyr_y, 0u, 0xffu);
    gyr_z = (uint16_t)src_p->gyr_z;
    dst_p[4] |= pack_right_shift_u16(gyr_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(gyr_z, 0u, 0xffu);

    return (6);
}

int xsens_rate_of_turn_unpack(
    struct xsens_rate_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t gyr_x;
    uint16_t gyr_y;
    uint16_t gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    gyr_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    gyr_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->gyr_x = (int16_t)gyr_x;
    gyr_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    gyr_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->gyr_y = (int16_t)gyr_y;
    gyr_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    gyr_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->gyr_z = (int16_t)gyr_z;

    return (0);
}

int xsens_rate_of_turn_init(struct xsens_rate_of_turn_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_rate_of_turn_t));

    return 0;
}

int16_t xsens_rate_of_turn_gyr_x_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_gyr_x_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_gyr_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_rate_of_turn_gyr_y_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_gyr_y_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_gyr_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_rate_of_turn_gyr_z_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_gyr_z_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_gyr_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_delta_q_pack(
    uint8_t *dst_p,
    const struct xsens_delta_q_t *src_p,
    size_t size)
{
    uint16_t delta_q1;
    uint16_t delta_q2;
    uint16_t delta_q3;
    uint16_t delta_q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    delta_q1 = (uint16_t)src_p->delta_q1;
    dst_p[0] |= pack_right_shift_u16(delta_q1, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(delta_q1, 0u, 0xffu);
    delta_q2 = (uint16_t)src_p->delta_q2;
    dst_p[2] |= pack_right_shift_u16(delta_q2, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(delta_q2, 0u, 0xffu);
    delta_q3 = (uint16_t)src_p->delta_q3;
    dst_p[4] |= pack_right_shift_u16(delta_q3, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(delta_q3, 0u, 0xffu);
    delta_q4 = (uint16_t)src_p->delta_q4;
    dst_p[6] |= pack_right_shift_u16(delta_q4, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(delta_q4, 0u, 0xffu);

    return (8);
}

int xsens_delta_q_unpack(
    struct xsens_delta_q_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t delta_q1;
    uint16_t delta_q2;
    uint16_t delta_q3;
    uint16_t delta_q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    delta_q1 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    delta_q1 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->delta_q1 = (int16_t)delta_q1;
    delta_q2 = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    delta_q2 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->delta_q2 = (int16_t)delta_q2;
    delta_q3 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    delta_q3 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->delta_q3 = (int16_t)delta_q3;
    delta_q4 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    delta_q4 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->delta_q4 = (int16_t)delta_q4;

    return (0);
}

int xsens_delta_q_init(struct xsens_delta_q_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_delta_q_t));

    return 0;
}

int16_t xsens_delta_q_delta_q1_encode(double value)
{
    return (int16_t)(value / 3.0518509476e-05);
}

double xsens_delta_q_delta_q1_decode(int16_t value)
{
    return ((double)value * 3.0518509476e-05);
}

bool xsens_delta_q_delta_q1_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int16_t xsens_delta_q_delta_q2_encode(double value)
{
    return (int16_t)(value / 3.0518509476e-05);
}

double xsens_delta_q_delta_q2_decode(int16_t value)
{
    return ((double)value * 3.0518509476e-05);
}

bool xsens_delta_q_delta_q2_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int16_t xsens_delta_q_delta_q3_encode(double value)
{
    return (int16_t)(value / 3.0518509476e-05);
}

double xsens_delta_q_delta_q3_decode(int16_t value)
{
    return ((double)value * 3.0518509476e-05);
}

bool xsens_delta_q_delta_q3_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int16_t xsens_delta_q_delta_q4_encode(double value)
{
    return (int16_t)(value / 3.0518509476e-05);
}

double xsens_delta_q_delta_q4_decode(int16_t value)
{
    return ((double)value * 3.0518509476e-05);
}

bool xsens_delta_q_delta_q4_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int xsens_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_acceleration_t *src_p,
    size_t size)
{
    uint16_t acc_x;
    uint16_t acc_y;
    uint16_t acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    acc_x = (uint16_t)src_p->acc_x;
    dst_p[0] |= pack_right_shift_u16(acc_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(acc_x, 0u, 0xffu);
    acc_y = (uint16_t)src_p->acc_y;
    dst_p[2] |= pack_right_shift_u16(acc_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(acc_y, 0u, 0xffu);
    acc_z = (uint16_t)src_p->acc_z;
    dst_p[4] |= pack_right_shift_u16(acc_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(acc_z, 0u, 0xffu);

    return (6);
}

int xsens_acceleration_unpack(
    struct xsens_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acc_x;
    uint16_t acc_y;
    uint16_t acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    acc_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    acc_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->acc_x = (int16_t)acc_x;
    acc_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    acc_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->acc_y = (int16_t)acc_y;
    acc_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    acc_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->acc_z = (int16_t)acc_z;

    return (0);
}

int xsens_acceleration_init(struct xsens_acceleration_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_acceleration_t));

    return 0;
}

int16_t xsens_acceleration_acc_x_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_acc_x_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_acc_x_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_acceleration_acc_y_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_acc_y_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_acc_y_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_acceleration_acc_z_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_acc_z_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_acc_z_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int xsens_free_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_free_acceleration_t *src_p,
    size_t size)
{
    uint16_t free_acc_x;
    uint16_t free_acc_y;
    uint16_t free_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    free_acc_x = (uint16_t)src_p->free_acc_x;
    dst_p[0] |= pack_right_shift_u16(free_acc_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(free_acc_x, 0u, 0xffu);
    free_acc_y = (uint16_t)src_p->free_acc_y;
    dst_p[2] |= pack_right_shift_u16(free_acc_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(free_acc_y, 0u, 0xffu);
    free_acc_z = (uint16_t)src_p->free_acc_z;
    dst_p[4] |= pack_right_shift_u16(free_acc_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(free_acc_z, 0u, 0xffu);

    return (6);
}

int xsens_free_acceleration_unpack(
    struct xsens_free_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t free_acc_x;
    uint16_t free_acc_y;
    uint16_t free_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    free_acc_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    free_acc_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->free_acc_x = (int16_t)free_acc_x;
    free_acc_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    free_acc_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->free_acc_y = (int16_t)free_acc_y;
    free_acc_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    free_acc_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->free_acc_z = (int16_t)free_acc_z;

    return (0);
}

int xsens_free_acceleration_init(struct xsens_free_acceleration_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_free_acceleration_t));

    return 0;
}

int16_t xsens_free_acceleration_free_acc_x_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_free_acceleration_free_acc_x_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_free_acceleration_free_acc_x_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_free_acceleration_free_acc_y_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_free_acceleration_free_acc_y_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_free_acceleration_free_acc_y_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_free_acceleration_free_acc_z_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_free_acceleration_free_acc_z_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_free_acceleration_free_acc_z_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int xsens_rate_of_turn_hr_pack(
    uint8_t *dst_p,
    const struct xsens_rate_of_turn_hr_t *src_p,
    size_t size)
{
    uint16_t hr_gyr_x;
    uint16_t hr_gyr_y;
    uint16_t hr_gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    hr_gyr_x = (uint16_t)src_p->hr_gyr_x;
    dst_p[0] |= pack_right_shift_u16(hr_gyr_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(hr_gyr_x, 0u, 0xffu);
    hr_gyr_y = (uint16_t)src_p->hr_gyr_y;
    dst_p[2] |= pack_right_shift_u16(hr_gyr_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(hr_gyr_y, 0u, 0xffu);
    hr_gyr_z = (uint16_t)src_p->hr_gyr_z;
    dst_p[4] |= pack_right_shift_u16(hr_gyr_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(hr_gyr_z, 0u, 0xffu);

    return (6);
}

int xsens_rate_of_turn_hr_unpack(
    struct xsens_rate_of_turn_hr_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t hr_gyr_x;
    uint16_t hr_gyr_y;
    uint16_t hr_gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    hr_gyr_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    hr_gyr_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->hr_gyr_x = (int16_t)hr_gyr_x;
    hr_gyr_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    hr_gyr_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->hr_gyr_y = (int16_t)hr_gyr_y;
    hr_gyr_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    hr_gyr_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->hr_gyr_z = (int16_t)hr_gyr_z;

    return (0);
}

int xsens_rate_of_turn_hr_init(struct xsens_rate_of_turn_hr_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_rate_of_turn_hr_t));

    return 0;
}

int16_t xsens_rate_of_turn_hr_hr_gyr_x_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_hr_hr_gyr_x_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_hr_hr_gyr_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_rate_of_turn_hr_hr_gyr_y_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_hr_hr_gyr_y_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_hr_hr_gyr_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_rate_of_turn_hr_hr_gyr_z_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_rate_of_turn_hr_hr_gyr_z_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_rate_of_turn_hr_hr_gyr_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_acceleration_hr_pack(
    uint8_t *dst_p,
    const struct xsens_acceleration_hr_t *src_p,
    size_t size)
{
    uint16_t hr_acc_x;
    uint16_t hr_acc_y;
    uint16_t hr_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    hr_acc_x = (uint16_t)src_p->hr_acc_x;
    dst_p[0] |= pack_right_shift_u16(hr_acc_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(hr_acc_x, 0u, 0xffu);
    hr_acc_y = (uint16_t)src_p->hr_acc_y;
    dst_p[2] |= pack_right_shift_u16(hr_acc_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(hr_acc_y, 0u, 0xffu);
    hr_acc_z = (uint16_t)src_p->hr_acc_z;
    dst_p[4] |= pack_right_shift_u16(hr_acc_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(hr_acc_z, 0u, 0xffu);

    return (6);
}

int xsens_acceleration_hr_unpack(
    struct xsens_acceleration_hr_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t hr_acc_x;
    uint16_t hr_acc_y;
    uint16_t hr_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    hr_acc_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    hr_acc_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->hr_acc_x = (int16_t)hr_acc_x;
    hr_acc_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    hr_acc_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->hr_acc_y = (int16_t)hr_acc_y;
    hr_acc_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    hr_acc_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->hr_acc_z = (int16_t)hr_acc_z;

    return (0);
}

int xsens_acceleration_hr_init(struct xsens_acceleration_hr_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_acceleration_hr_t));

    return 0;
}

int16_t xsens_acceleration_hr_hr_acc_x_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_hr_hr_acc_x_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_hr_hr_acc_x_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_acceleration_hr_hr_acc_y_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_hr_hr_acc_y_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_hr_hr_acc_y_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_acceleration_hr_hr_acc_z_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_acceleration_hr_hr_acc_z_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_acceleration_hr_hr_acc_z_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int xsens_magnetic_field_pack(
    uint8_t *dst_p,
    const struct xsens_magnetic_field_t *src_p,
    size_t size)
{
    uint16_t mag_x;
    uint16_t mag_y;
    uint16_t mag_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    mag_x = (uint16_t)src_p->mag_x;
    dst_p[0] |= pack_right_shift_u16(mag_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(mag_x, 0u, 0xffu);
    mag_y = (uint16_t)src_p->mag_y;
    dst_p[2] |= pack_right_shift_u16(mag_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(mag_y, 0u, 0xffu);
    mag_z = (uint16_t)src_p->mag_z;
    dst_p[4] |= pack_right_shift_u16(mag_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(mag_z, 0u, 0xffu);

    return (6);
}

int xsens_magnetic_field_unpack(
    struct xsens_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t mag_x;
    uint16_t mag_y;
    uint16_t mag_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    mag_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    mag_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->mag_x = (int16_t)mag_x;
    mag_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    mag_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->mag_y = (int16_t)mag_y;
    mag_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    mag_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->mag_z = (int16_t)mag_z;

    return (0);
}

int xsens_magnetic_field_init(struct xsens_magnetic_field_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_magnetic_field_t));

    return 0;
}

int16_t xsens_magnetic_field_mag_x_encode(double value)
{
    return (int16_t)(value / 0.0009765625);
}

double xsens_magnetic_field_mag_x_decode(int16_t value)
{
    return ((double)value * 0.0009765625);
}

bool xsens_magnetic_field_mag_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_magnetic_field_mag_y_encode(double value)
{
    return (int16_t)(value / 0.0009765625);
}

double xsens_magnetic_field_mag_y_decode(int16_t value)
{
    return ((double)value * 0.0009765625);
}

bool xsens_magnetic_field_mag_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_magnetic_field_mag_z_encode(double value)
{
    return (int16_t)(value / 0.0009765625);
}

double xsens_magnetic_field_mag_z_decode(int16_t value)
{
    return ((double)value * 0.0009765625);
}

bool xsens_magnetic_field_mag_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_temperature_pack(
    uint8_t *dst_p,
    const struct xsens_temperature_t *src_p,
    size_t size)
{
    uint16_t temperature;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    temperature = (uint16_t)src_p->temperature;
    dst_p[0] |= pack_right_shift_u16(temperature, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(temperature, 0u, 0xffu);

    return (2);
}

int xsens_temperature_unpack(
    struct xsens_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t temperature;

    if (size < 2u) {
        return (-EINVAL);
    }

    temperature = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    temperature |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->temperature = (int16_t)temperature;

    return (0);
}

int xsens_temperature_init(struct xsens_temperature_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_temperature_t));

    return 0;
}

int16_t xsens_temperature_temperature_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_temperature_temperature_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_temperature_temperature_is_in_range(int16_t value)
{
    return ((value >= -10240) && (value <= 21760));
}

int xsens_barometric_pressure_pack(
    uint8_t *dst_p,
    const struct xsens_barometric_pressure_t *src_p,
    size_t size)
{
    uint32_t pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    pressure = (uint32_t)src_p->pressure;
    dst_p[0] |= pack_right_shift_u32(pressure, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pressure, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pressure, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(pressure, 0u, 0xffu);

    return (4);
}

int xsens_barometric_pressure_unpack(
    struct xsens_barometric_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    pressure = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    pressure |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    pressure |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    pressure |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->pressure = (int32_t)pressure;

    return (0);
}

int xsens_barometric_pressure_init(struct xsens_barometric_pressure_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_barometric_pressure_t));

    return 0;
}

int32_t xsens_barometric_pressure_pressure_encode(double value)
{
    return (int32_t)(value);
}

double xsens_barometric_pressure_pressure_decode(int32_t value)
{
    return ((double)value);
}

bool xsens_barometric_pressure_pressure_is_in_range(int32_t value)
{
    return ((value >= 30000) && (value <= 125000));
}

int xsens_utc_pack(
    uint8_t *dst_p,
    const struct xsens_utc_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->year, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->month, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->day, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->hour, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->minute, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->second, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->tenthms, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->tenthms, 0u, 0xffu);

    return (8);
}

int xsens_utc_unpack(
    struct xsens_utc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->year = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->month = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->day = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->hour = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->minute = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->second = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->tenthms = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->tenthms |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int xsens_utc_init(struct xsens_utc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_utc_t));

    return 0;
}

uint8_t xsens_utc_year_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_year_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_year_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t xsens_utc_month_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_month_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_month_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 12u));
}

uint8_t xsens_utc_day_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_day_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_day_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 31u));
}

uint8_t xsens_utc_hour_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_hour_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_hour_is_in_range(uint8_t value)
{
    return (value <= 24u);
}

uint8_t xsens_utc_minute_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_minute_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_minute_is_in_range(uint8_t value)
{
    return (value <= 60u);
}

uint8_t xsens_utc_second_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_utc_second_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_utc_second_is_in_range(uint8_t value)
{
    return (value <= 60u);
}

uint16_t xsens_utc_tenthms_encode(double value)
{
    return (uint16_t)(value);
}

double xsens_utc_tenthms_decode(uint16_t value)
{
    return ((double)value);
}

bool xsens_utc_tenthms_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int xsens_euler_angles_pack(
    uint8_t *dst_p,
    const struct xsens_euler_angles_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    roll = (uint16_t)src_p->roll;
    dst_p[0] |= pack_right_shift_u16(roll, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(roll, 0u, 0xffu);
    pitch = (uint16_t)src_p->pitch;
    dst_p[2] |= pack_right_shift_u16(pitch, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(pitch, 0u, 0xffu);
    yaw = (uint16_t)src_p->yaw;
    dst_p[4] |= pack_right_shift_u16(yaw, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(yaw, 0u, 0xffu);

    return (6);
}

int xsens_euler_angles_unpack(
    struct xsens_euler_angles_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    roll = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    roll |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->roll = (int16_t)roll;
    pitch = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    pitch |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->pitch = (int16_t)pitch;
    yaw = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    yaw |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->yaw = (int16_t)yaw;

    return (0);
}

int xsens_euler_angles_init(struct xsens_euler_angles_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_euler_angles_t));

    return 0;
}

int16_t xsens_euler_angles_roll_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_euler_angles_roll_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_euler_angles_roll_is_in_range(int16_t value)
{
    return ((value >= -23040) && (value <= 23040));
}

int16_t xsens_euler_angles_pitch_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_euler_angles_pitch_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_euler_angles_pitch_is_in_range(int16_t value)
{
    return ((value >= -11520) && (value <= 11520));
}

int16_t xsens_euler_angles_yaw_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_euler_angles_yaw_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_euler_angles_yaw_is_in_range(int16_t value)
{
    return ((value >= -23040) && (value <= 23040));
}

int xsens_lat_lon_pack(
    uint8_t *dst_p,
    const struct xsens_lat_lon_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    latitude = (uint32_t)src_p->latitude;
    dst_p[0] |= pack_right_shift_u32(latitude, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(latitude, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(latitude, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(latitude, 0u, 0xffu);
    longitude = (uint32_t)src_p->longitude;
    dst_p[4] |= pack_right_shift_u32(longitude, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(longitude, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(longitude, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(longitude, 0u, 0xffu);

    return (8);
}

int xsens_lat_lon_unpack(
    struct xsens_lat_lon_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    latitude = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    latitude |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->latitude = (int32_t)latitude;
    longitude = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    longitude |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);
    dst_p->longitude = (int32_t)longitude;

    return (0);
}

int xsens_lat_lon_init(struct xsens_lat_lon_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_lat_lon_t));

    return 0;
}

int32_t xsens_lat_lon_latitude_encode(double value)
{
    return (int32_t)(value / 5.9604644775e-08);
}

double xsens_lat_lon_latitude_decode(int32_t value)
{
    return ((double)value * 5.9604644775e-08);
}

bool xsens_lat_lon_latitude_is_in_range(int32_t value)
{
    return ((value >= -1509949440) && (value <= 1509949440));
}

int32_t xsens_lat_lon_longitude_encode(double value)
{
    return (int32_t)(value / 1.1920928955e-07);
}

double xsens_lat_lon_longitude_decode(int32_t value)
{
    return ((double)value * 1.1920928955e-07);
}

bool xsens_lat_lon_longitude_is_in_range(int32_t value)
{
    return ((value >= -1509949440) && (value <= 1509949440));
}

int xsens_altitude_ellipsoid_pack(
    uint8_t *dst_p,
    const struct xsens_altitude_ellipsoid_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_right_shift_u32(src_p->alt_ellipsoid, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->alt_ellipsoid, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->alt_ellipsoid, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->alt_ellipsoid, 0u, 0xffu);

    return (4);
}

int xsens_altitude_ellipsoid_unpack(
    struct xsens_altitude_ellipsoid_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->alt_ellipsoid = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->alt_ellipsoid |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->alt_ellipsoid |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->alt_ellipsoid |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);

    return (0);
}

int xsens_altitude_ellipsoid_init(struct xsens_altitude_ellipsoid_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_altitude_ellipsoid_t));

    return 0;
}

uint32_t xsens_altitude_ellipsoid_alt_ellipsoid_encode(double value)
{
    return (uint32_t)(value / 3.0517578125e-05);
}

double xsens_altitude_ellipsoid_alt_ellipsoid_decode(uint32_t value)
{
    return ((double)value * 3.0517578125e-05);
}

bool xsens_altitude_ellipsoid_alt_ellipsoid_is_in_range(uint32_t value)
{
    return (value <= 1638400000u);
}

int xsens_position_ecef_x_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_x_t *src_p,
    size_t size)
{
    uint32_t position_ecef_x;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_ecef_x = (uint32_t)src_p->position_ecef_x;
    dst_p[0] |= pack_right_shift_u32(position_ecef_x, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_ecef_x, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_ecef_x, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(position_ecef_x, 0u, 0xffu);

    return (4);
}

int xsens_position_ecef_x_unpack(
    struct xsens_position_ecef_x_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_ecef_x;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_ecef_x = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    position_ecef_x |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    position_ecef_x |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    position_ecef_x |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->position_ecef_x = (int32_t)position_ecef_x;

    return (0);
}

int xsens_position_ecef_x_init(struct xsens_position_ecef_x_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_position_ecef_x_t));

    return 0;
}

int32_t xsens_position_ecef_x_position_ecef_x_encode(double value)
{
    return (int32_t)(value / 0.00390625);
}

double xsens_position_ecef_x_position_ecef_x_decode(int32_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_position_ecef_x_position_ecef_x_is_in_range(int32_t value)
{
    return ((value >= -1664000000) && (value <= 1664000000));
}

int xsens_position_ecef_y_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_y_t *src_p,
    size_t size)
{
    uint32_t position_ecef_y;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_ecef_y = (uint32_t)src_p->position_ecef_y;
    dst_p[0] |= pack_right_shift_u32(position_ecef_y, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_ecef_y, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_ecef_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(position_ecef_y, 0u, 0xffu);

    return (4);
}

int xsens_position_ecef_y_unpack(
    struct xsens_position_ecef_y_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_ecef_y;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_ecef_y = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    position_ecef_y |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    position_ecef_y |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    position_ecef_y |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->position_ecef_y = (int32_t)position_ecef_y;

    return (0);
}

int xsens_position_ecef_y_init(struct xsens_position_ecef_y_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_position_ecef_y_t));

    return 0;
}

int32_t xsens_position_ecef_y_position_ecef_y_encode(double value)
{
    return (int32_t)(value / 0.00390625);
}

double xsens_position_ecef_y_position_ecef_y_decode(int32_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_position_ecef_y_position_ecef_y_is_in_range(int32_t value)
{
    return ((value >= -1664000000) && (value <= 1664000000));
}

int xsens_position_ecef_z_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_z_t *src_p,
    size_t size)
{
    uint32_t position_ecef_z;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_ecef_z = (uint32_t)src_p->position_ecef_z;
    dst_p[0] |= pack_right_shift_u32(position_ecef_z, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_ecef_z, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_ecef_z, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(position_ecef_z, 0u, 0xffu);

    return (4);
}

int xsens_position_ecef_z_unpack(
    struct xsens_position_ecef_z_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_ecef_z;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_ecef_z = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    position_ecef_z |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    position_ecef_z |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    position_ecef_z |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->position_ecef_z = (int32_t)position_ecef_z;

    return (0);
}

int xsens_position_ecef_z_init(struct xsens_position_ecef_z_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_position_ecef_z_t));

    return 0;
}

int32_t xsens_position_ecef_z_position_ecef_z_encode(double value)
{
    return (int32_t)(value / 0.00390625);
}

double xsens_position_ecef_z_position_ecef_z_decode(int32_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_position_ecef_z_position_ecef_z_is_in_range(int32_t value)
{
    return ((value >= -1664000000) && (value <= 1664000000));
}

int xsens_velocity_pack(
    uint8_t *dst_p,
    const struct xsens_velocity_t *src_p,
    size_t size)
{
    uint16_t vel_x;
    uint16_t vel_y;
    uint16_t vel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    vel_x = (uint16_t)src_p->vel_x;
    dst_p[0] |= pack_right_shift_u16(vel_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(vel_x, 0u, 0xffu);
    vel_y = (uint16_t)src_p->vel_y;
    dst_p[2] |= pack_right_shift_u16(vel_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(vel_y, 0u, 0xffu);
    vel_z = (uint16_t)src_p->vel_z;
    dst_p[4] |= pack_right_shift_u16(vel_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(vel_z, 0u, 0xffu);

    return (6);
}

int xsens_velocity_unpack(
    struct xsens_velocity_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vel_x;
    uint16_t vel_y;
    uint16_t vel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    vel_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    vel_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->vel_x = (int16_t)vel_x;
    vel_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    vel_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->vel_y = (int16_t)vel_y;
    vel_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    vel_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->vel_z = (int16_t)vel_z;

    return (0);
}

int xsens_velocity_init(struct xsens_velocity_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_velocity_t));

    return 0;
}

int16_t xsens_velocity_vel_x_encode(double value)
{
    return (int16_t)(value / 0.015625);
}

double xsens_velocity_vel_x_decode(int16_t value)
{
    return ((double)value * 0.015625);
}

bool xsens_velocity_vel_x_is_in_range(int16_t value)
{
    return ((value >= -32000) && (value <= 32000));
}

int16_t xsens_velocity_vel_y_encode(double value)
{
    return (int16_t)(value / 0.015625);
}

double xsens_velocity_vel_y_decode(int16_t value)
{
    return ((double)value * 0.015625);
}

bool xsens_velocity_vel_y_is_in_range(int16_t value)
{
    return ((value >= -32000) && (value <= 32000));
}

int16_t xsens_velocity_vel_z_encode(double value)
{
    return (int16_t)(value / 0.015625);
}

double xsens_velocity_vel_z_decode(int16_t value)
{
    return ((double)value * 0.015625);
}

bool xsens_velocity_vel_z_is_in_range(int16_t value)
{
    return ((value >= -32000) && (value <= 32000));
}

int xsens_gnss_receiver_status_pack(
    uint8_t *dst_p,
    const struct xsens_gnss_receiver_status_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->fix_type, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->num_sv, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->flags, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->valid, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->num_svs, 0u, 0xffu);

    return (5);
}

int xsens_gnss_receiver_status_unpack(
    struct xsens_gnss_receiver_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->fix_type = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->num_sv = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->flags = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->valid = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->num_svs = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int xsens_gnss_receiver_status_init(struct xsens_gnss_receiver_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_gnss_receiver_status_t));

    return 0;
}

uint8_t xsens_gnss_receiver_status_fix_type_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_gnss_receiver_status_fix_type_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_gnss_receiver_status_fix_type_is_in_range(uint8_t value)
{
    return (value <= 5u);
}

uint8_t xsens_gnss_receiver_status_num_sv_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_gnss_receiver_status_num_sv_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_gnss_receiver_status_num_sv_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t xsens_gnss_receiver_status_flags_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_gnss_receiver_status_flags_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_gnss_receiver_status_flags_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t xsens_gnss_receiver_status_valid_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_gnss_receiver_status_valid_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_gnss_receiver_status_valid_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t xsens_gnss_receiver_status_num_svs_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_gnss_receiver_status_num_svs_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_gnss_receiver_status_num_svs_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int xsens_gnss_receiver_dop_pack(
    uint8_t *dst_p,
    const struct xsens_gnss_receiver_dop_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->pdop, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->pdop, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->tdop, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->tdop, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->vdop, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->vdop, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->hdop, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->hdop, 0u, 0xffu);

    return (8);
}

int xsens_gnss_receiver_dop_unpack(
    struct xsens_gnss_receiver_dop_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->pdop = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->pdop |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->tdop = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->tdop |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->vdop = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->vdop |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->hdop = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->hdop |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int xsens_gnss_receiver_dop_init(struct xsens_gnss_receiver_dop_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct xsens_gnss_receiver_dop_t));

    return 0;
}

uint16_t xsens_gnss_receiver_dop_pdop_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double xsens_gnss_receiver_dop_pdop_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool xsens_gnss_receiver_dop_pdop_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

uint16_t xsens_gnss_receiver_dop_tdop_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double xsens_gnss_receiver_dop_tdop_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool xsens_gnss_receiver_dop_tdop_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

uint16_t xsens_gnss_receiver_dop_vdop_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double xsens_gnss_receiver_dop_vdop_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool xsens_gnss_receiver_dop_vdop_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

uint16_t xsens_gnss_receiver_dop_hdop_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double xsens_gnss_receiver_dop_hdop_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool xsens_gnss_receiver_dop_hdop_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}
