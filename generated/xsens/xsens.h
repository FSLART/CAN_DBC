/**
 * @file xsens.h
 *
 * @brief This header file was generated by cantools version 40.2.3 Sat Jul 26 00:48:01 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef XSENS_H
#define XSENS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define XSENS_ERROR_FRAME_ID (0x01u)
#define XSENS_WARNING_FRAME_ID (0x02u)
#define XSENS_SAMPLE_TIME_FRAME_ID (0x05u)
#define XSENS_GROUP_COUNTER_FRAME_ID (0x06u)
#define XSENS_STATUS_WORD_FRAME_ID (0x11u)
#define XSENS_QUATERNION_FRAME_ID (0x21u)
#define XSENS_DELTA_V_FRAME_ID (0x31u)
#define XSENS_RATE_OF_TURN_FRAME_ID (0x32u)
#define XSENS_DELTA_Q_FRAME_ID (0x33u)
#define XSENS_ACCELERATION_FRAME_ID (0x34u)
#define XSENS_FREE_ACCELERATION_FRAME_ID (0x35u)
#define XSENS_RATE_OF_TURN_HR_FRAME_ID (0x61u)
#define XSENS_ACCELERATION_HR_FRAME_ID (0x62u)
#define XSENS_MAGNETIC_FIELD_FRAME_ID (0x41u)
#define XSENS_TEMPERATURE_FRAME_ID (0x51u)
#define XSENS_BAROMETRIC_PRESSURE_FRAME_ID (0x52u)
#define XSENS_UTC_FRAME_ID (0x07u)
#define XSENS_EULER_ANGLES_FRAME_ID (0x22u)
#define XSENS_LAT_LON_FRAME_ID (0x71u)
#define XSENS_ALTITUDE_ELLIPSOID_FRAME_ID (0x72u)
#define XSENS_POSITION_ECEF_X_FRAME_ID (0x73u)
#define XSENS_POSITION_ECEF_Y_FRAME_ID (0x74u)
#define XSENS_POSITION_ECEF_Z_FRAME_ID (0x75u)
#define XSENS_VELOCITY_FRAME_ID (0x76u)
#define XSENS_GNSS_RECEIVER_STATUS_FRAME_ID (0x79u)
#define XSENS_GNSS_RECEIVER_DOP_FRAME_ID (0x7au)

/* Frame lengths in bytes. */
#define XSENS_ERROR_LENGTH (1u)
#define XSENS_WARNING_LENGTH (1u)
#define XSENS_SAMPLE_TIME_LENGTH (4u)
#define XSENS_GROUP_COUNTER_LENGTH (2u)
#define XSENS_STATUS_WORD_LENGTH (4u)
#define XSENS_QUATERNION_LENGTH (8u)
#define XSENS_DELTA_V_LENGTH (7u)
#define XSENS_RATE_OF_TURN_LENGTH (6u)
#define XSENS_DELTA_Q_LENGTH (8u)
#define XSENS_ACCELERATION_LENGTH (6u)
#define XSENS_FREE_ACCELERATION_LENGTH (6u)
#define XSENS_RATE_OF_TURN_HR_LENGTH (6u)
#define XSENS_ACCELERATION_HR_LENGTH (6u)
#define XSENS_MAGNETIC_FIELD_LENGTH (6u)
#define XSENS_TEMPERATURE_LENGTH (2u)
#define XSENS_BAROMETRIC_PRESSURE_LENGTH (4u)
#define XSENS_UTC_LENGTH (8u)
#define XSENS_EULER_ANGLES_LENGTH (6u)
#define XSENS_LAT_LON_LENGTH (8u)
#define XSENS_ALTITUDE_ELLIPSOID_LENGTH (4u)
#define XSENS_POSITION_ECEF_X_LENGTH (4u)
#define XSENS_POSITION_ECEF_Y_LENGTH (4u)
#define XSENS_POSITION_ECEF_Z_LENGTH (4u)
#define XSENS_VELOCITY_LENGTH (6u)
#define XSENS_GNSS_RECEIVER_STATUS_LENGTH (5u)
#define XSENS_GNSS_RECEIVER_DOP_LENGTH (8u)

/* Extended or standard frame types. */
#define XSENS_ERROR_IS_EXTENDED (0)
#define XSENS_WARNING_IS_EXTENDED (0)
#define XSENS_SAMPLE_TIME_IS_EXTENDED (0)
#define XSENS_GROUP_COUNTER_IS_EXTENDED (0)
#define XSENS_STATUS_WORD_IS_EXTENDED (0)
#define XSENS_QUATERNION_IS_EXTENDED (0)
#define XSENS_DELTA_V_IS_EXTENDED (0)
#define XSENS_RATE_OF_TURN_IS_EXTENDED (0)
#define XSENS_DELTA_Q_IS_EXTENDED (0)
#define XSENS_ACCELERATION_IS_EXTENDED (0)
#define XSENS_FREE_ACCELERATION_IS_EXTENDED (0)
#define XSENS_RATE_OF_TURN_HR_IS_EXTENDED (0)
#define XSENS_ACCELERATION_HR_IS_EXTENDED (0)
#define XSENS_MAGNETIC_FIELD_IS_EXTENDED (0)
#define XSENS_TEMPERATURE_IS_EXTENDED (0)
#define XSENS_BAROMETRIC_PRESSURE_IS_EXTENDED (0)
#define XSENS_UTC_IS_EXTENDED (0)
#define XSENS_EULER_ANGLES_IS_EXTENDED (0)
#define XSENS_LAT_LON_IS_EXTENDED (0)
#define XSENS_ALTITUDE_ELLIPSOID_IS_EXTENDED (0)
#define XSENS_POSITION_ECEF_X_IS_EXTENDED (0)
#define XSENS_POSITION_ECEF_Y_IS_EXTENDED (0)
#define XSENS_POSITION_ECEF_Z_IS_EXTENDED (0)
#define XSENS_VELOCITY_IS_EXTENDED (0)
#define XSENS_GNSS_RECEIVER_STATUS_IS_EXTENDED (0)
#define XSENS_GNSS_RECEIVER_DOP_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define XSENS_STATUS_WORD_HAVE_GNSS_TIME_PULSE_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_HAVE_GNSS_TIME_PULSE_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_RTK_STATUS_NO_RTK_CHOICE (0u)
#define XSENS_STATUS_WORD_RTK_STATUS_RTK_FLOATING_CHOICE (1u)
#define XSENS_STATUS_WORD_RTK_STATUS_RTK_FIXED_CHOICE (2u)

#define XSENS_STATUS_WORD_FILTER_MODE_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_FILTER_MODE_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_MAG_Z_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_MAG_Z_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_RETRANSMITTED_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_RETRANSMITTED_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIPPING_DETECTED_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIPPING_DETECTED_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_INTERPOLATED_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_INTERPOLATED_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_SYNC_IN_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_SYNC_IN_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_SYNC_OUT_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_SYNC_OUT_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_ACC_X_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_ACC_X_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_ACC_Y_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_ACC_Y_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_ACC_Z_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_ACC_Z_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_GYR_X_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_GYR_X_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_GYR_Y_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_GYR_Y_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_GYR_Z_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_GYR_Z_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_MAG_X_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_MAG_X_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_CLIP_MAG_Y_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_CLIP_MAG_Y_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_SELF_TEST_OK_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_SELF_TEST_OK_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_ORIENTATION_VALID_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_ORIENTATION_VALID_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_GPS_VALID_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_GPS_VALID_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_NO_ROTATION_ABORTED_CHOICE (1u)
#define XSENS_STATUS_WORD_NO_ROTATION_SAMPLES_REJECTED_CHOICE (2u)
#define XSENS_STATUS_WORD_NO_ROTATION_RUNNING_NORMALLY_CHOICE (3u)

#define XSENS_STATUS_WORD_REPRESENTATIVE_MOTION_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_REPRESENTATIVE_MOTION_TRUE_CHOICE (1u)

#define XSENS_STATUS_WORD_EXTERNAL_CLOCK_SYNCED_FALSE_CHOICE (0u)
#define XSENS_STATUS_WORD_EXTERNAL_CLOCK_SYNCED_TRUE_CHOICE (1u)

/* Frame Names. */
#define XSENS_ERROR_NAME "Error"
#define XSENS_WARNING_NAME "Warning"
#define XSENS_SAMPLE_TIME_NAME "SampleTime"
#define XSENS_GROUP_COUNTER_NAME "GroupCounter"
#define XSENS_STATUS_WORD_NAME "StatusWord"
#define XSENS_QUATERNION_NAME "Quaternion"
#define XSENS_DELTA_V_NAME "DeltaV"
#define XSENS_RATE_OF_TURN_NAME "RateOfTurn"
#define XSENS_DELTA_Q_NAME "DeltaQ"
#define XSENS_ACCELERATION_NAME "Acceleration"
#define XSENS_FREE_ACCELERATION_NAME "FreeAcceleration"
#define XSENS_RATE_OF_TURN_HR_NAME "RateOfTurnHR"
#define XSENS_ACCELERATION_HR_NAME "AccelerationHR"
#define XSENS_MAGNETIC_FIELD_NAME "MagneticField"
#define XSENS_TEMPERATURE_NAME "Temperature"
#define XSENS_BAROMETRIC_PRESSURE_NAME "BarometricPressure"
#define XSENS_UTC_NAME "UTC"
#define XSENS_EULER_ANGLES_NAME "EulerAngles"
#define XSENS_LAT_LON_NAME "LatLon"
#define XSENS_ALTITUDE_ELLIPSOID_NAME "AltitudeEllipsoid"
#define XSENS_POSITION_ECEF_X_NAME "PositionEcef_X"
#define XSENS_POSITION_ECEF_Y_NAME "PositionEcef_Y"
#define XSENS_POSITION_ECEF_Z_NAME "PositionEcef_Z"
#define XSENS_VELOCITY_NAME "Velocity"
#define XSENS_GNSS_RECEIVER_STATUS_NAME "GnssReceiverStatus"
#define XSENS_GNSS_RECEIVER_DOP_NAME "GnssReceiverDop"

/* Signal Names. */
#define XSENS_WARNING_WARNING_CODE_NAME "WarningCode"
#define XSENS_SAMPLE_TIME_TIMESTAMP_NAME "Timestamp"
#define XSENS_GROUP_COUNTER_COUNTER_NAME "Counter"
#define XSENS_STATUS_WORD_HAVE_GNSS_TIME_PULSE_NAME "HaveGnssTimePulse"
#define XSENS_STATUS_WORD_RTK_STATUS_NAME "RtkStatus"
#define XSENS_STATUS_WORD_FILTER_MODE_NAME "FilterMode"
#define XSENS_STATUS_WORD_CLIP_MAG_Z_NAME "ClipMagZ"
#define XSENS_STATUS_WORD_RETRANSMITTED_NAME "Retransmitted"
#define XSENS_STATUS_WORD_CLIPPING_DETECTED_NAME "ClippingDetected"
#define XSENS_STATUS_WORD_INTERPOLATED_NAME "Interpolated"
#define XSENS_STATUS_WORD_SYNC_IN_NAME "SyncIn"
#define XSENS_STATUS_WORD_SYNC_OUT_NAME "SyncOut"
#define XSENS_STATUS_WORD_CLIP_ACC_X_NAME "ClipAccX"
#define XSENS_STATUS_WORD_CLIP_ACC_Y_NAME "ClipAccY"
#define XSENS_STATUS_WORD_CLIP_ACC_Z_NAME "ClipAccZ"
#define XSENS_STATUS_WORD_CLIP_GYR_X_NAME "ClipGyrX"
#define XSENS_STATUS_WORD_CLIP_GYR_Y_NAME "ClipGyrY"
#define XSENS_STATUS_WORD_CLIP_GYR_Z_NAME "ClipGyrZ"
#define XSENS_STATUS_WORD_CLIP_MAG_X_NAME "ClipMagX"
#define XSENS_STATUS_WORD_CLIP_MAG_Y_NAME "ClipMagY"
#define XSENS_STATUS_WORD_SELF_TEST_OK_NAME "SelfTestOk"
#define XSENS_STATUS_WORD_ORIENTATION_VALID_NAME "OrientationValid"
#define XSENS_STATUS_WORD_GPS_VALID_NAME "GpsValid"
#define XSENS_STATUS_WORD_NO_ROTATION_NAME "NoRotation"
#define XSENS_STATUS_WORD_REPRESENTATIVE_MOTION_NAME "RepresentativeMotion"
#define XSENS_STATUS_WORD_EXTERNAL_CLOCK_SYNCED_NAME "ExternalClockSynced"
#define XSENS_QUATERNION_Q0_NAME "Q0"
#define XSENS_QUATERNION_Q1_NAME "Q1"
#define XSENS_QUATERNION_Q2_NAME "Q2"
#define XSENS_QUATERNION_Q3_NAME "Q3"
#define XSENS_DELTA_V_X_NAME "X"
#define XSENS_DELTA_V_Y_NAME "Y"
#define XSENS_DELTA_V_Z_NAME "Z"
#define XSENS_DELTA_V_EXPONENT_NAME "Exponent"
#define XSENS_RATE_OF_TURN_GYR_X_NAME "gyrX"
#define XSENS_RATE_OF_TURN_GYR_Y_NAME "gyrY"
#define XSENS_RATE_OF_TURN_GYR_Z_NAME "gyrZ"
#define XSENS_DELTA_Q_DELTA_Q1_NAME "DeltaQ1"
#define XSENS_DELTA_Q_DELTA_Q2_NAME "DeltaQ2"
#define XSENS_DELTA_Q_DELTA_Q3_NAME "DeltaQ3"
#define XSENS_DELTA_Q_DELTA_Q4_NAME "DeltaQ4"
#define XSENS_ACCELERATION_ACC_X_NAME "accX"
#define XSENS_ACCELERATION_ACC_Y_NAME "accY"
#define XSENS_ACCELERATION_ACC_Z_NAME "accZ"
#define XSENS_FREE_ACCELERATION_FREE_ACC_X_NAME "FreeAccX"
#define XSENS_FREE_ACCELERATION_FREE_ACC_Y_NAME "FreeAccY"
#define XSENS_FREE_ACCELERATION_FREE_ACC_Z_NAME "FreeAccZ"
#define XSENS_RATE_OF_TURN_HR_HR_GYR_X_NAME "HrGyrX"
#define XSENS_RATE_OF_TURN_HR_HR_GYR_Y_NAME "HrGyrY"
#define XSENS_RATE_OF_TURN_HR_HR_GYR_Z_NAME "HrGyrZ"
#define XSENS_ACCELERATION_HR_HR_ACC_X_NAME "HrAccX"
#define XSENS_ACCELERATION_HR_HR_ACC_Y_NAME "HrAccY"
#define XSENS_ACCELERATION_HR_HR_ACC_Z_NAME "HrAccZ"
#define XSENS_MAGNETIC_FIELD_MAG_X_NAME "magX"
#define XSENS_MAGNETIC_FIELD_MAG_Y_NAME "magY"
#define XSENS_MAGNETIC_FIELD_MAG_Z_NAME "magZ"
#define XSENS_TEMPERATURE_TEMPERATURE_NAME "Temperature"
#define XSENS_BAROMETRIC_PRESSURE_PRESSURE_NAME "Pressure"
#define XSENS_UTC_YEAR_NAME "year"
#define XSENS_UTC_MONTH_NAME "month"
#define XSENS_UTC_DAY_NAME "day"
#define XSENS_UTC_HOUR_NAME "hour"
#define XSENS_UTC_MINUTE_NAME "minute"
#define XSENS_UTC_SECOND_NAME "second"
#define XSENS_UTC_TENTHMS_NAME "tenthms"
#define XSENS_EULER_ANGLES_ROLL_NAME "roll"
#define XSENS_EULER_ANGLES_PITCH_NAME "pitch"
#define XSENS_EULER_ANGLES_YAW_NAME "yaw"
#define XSENS_LAT_LON_LATITUDE_NAME "latitude"
#define XSENS_LAT_LON_LONGITUDE_NAME "longitude"
#define XSENS_ALTITUDE_ELLIPSOID_ALT_ELLIPSOID_NAME "altEllipsoid"
#define XSENS_POSITION_ECEF_X_POSITION_ECEF_X_NAME "PositionEcef_X"
#define XSENS_POSITION_ECEF_Y_POSITION_ECEF_Y_NAME "PositionEcef_Y"
#define XSENS_POSITION_ECEF_Z_POSITION_ECEF_Z_NAME "PositionEcef_Z"
#define XSENS_VELOCITY_VEL_X_NAME "velX"
#define XSENS_VELOCITY_VEL_Y_NAME "velY"
#define XSENS_VELOCITY_VEL_Z_NAME "velZ"
#define XSENS_GNSS_RECEIVER_STATUS_FIX_TYPE_NAME "fixType"
#define XSENS_GNSS_RECEIVER_STATUS_NUM_SV_NAME "numSv"
#define XSENS_GNSS_RECEIVER_STATUS_FLAGS_NAME "flags"
#define XSENS_GNSS_RECEIVER_STATUS_VALID_NAME "valid"
#define XSENS_GNSS_RECEIVER_STATUS_NUM_SVS_NAME "numSvs"
#define XSENS_GNSS_RECEIVER_DOP_PDOP_NAME "pdop"
#define XSENS_GNSS_RECEIVER_DOP_TDOP_NAME "tdop"
#define XSENS_GNSS_RECEIVER_DOP_VDOP_NAME "vdop"
#define XSENS_GNSS_RECEIVER_DOP_HDOP_NAME "hdop"

/**
 * Signals in message Error.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_error_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Warning.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_warning_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t warning_code;
};

/**
 * Signals in message SampleTime.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_sample_time_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;
};

/**
 * Signals in message GroupCounter.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_group_counter_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t counter;
};

/**
 * Signals in message StatusWord.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_status_word_t {
    /**
     * Indicates that the 1PPS GNSS time pulse is present
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t have_gnss_time_pulse;

    /**
     * Mask for 2 bit RTK status field
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtk_status;

    /**
     * Mask for the 3 bit filter mode field
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t filter_mode;

    /**
     * Indicates if there was clipping on the Z-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_z;

    /**
     * When set Indicates the sample was received as a retransmission
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retransmitted;

    /**
     * When set Indicates clipping has occurred
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clipping_detected;

    /**
     * When set Indicates the sample is an interpolation between other samples
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t interpolated;

    /**
     * When set indicates a sync-in event has been triggered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sync_in;

    /**
     * When set Indicates a sync-out event has been generated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sync_out;

    /**
     * Indicates if there was clipping on the X-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_x;

    /**
     * Indicates if there was clipping on the Y-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_y;

    /**
     * Indicates if there was clipping on the Z-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_z;

    /**
     * Indicates if there was clipping on the X-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_x;

    /**
     * Indicates if there was clipping on the Y-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_y;

    /**
     * Indicates if there was clipping on the Z-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_z;

    /**
     * Indicates if there was clipping on the X-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_x;

    /**
     * Indicates if there was clipping on the Y-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_y;

    /**
     * Set when the self test result was ok
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t self_test_ok;

    /**
     * Set when the computed orientation is valid. The orientation may be invalid during startup or when the Xsens_Sensor data is clipping during violent (for the device) motion
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t orientation_valid;

    /**
     * Set when the device has a GPS receiver and the receiver says that there is a GPS position fix.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_valid;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_rotation;

    /**
     * Indicates if the In-Run Compass Calibration is doing the representative motion analysis
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t representative_motion;

    /**
     * Indicates whether the internal clock is synced with an external clock (Either GNNS or custom provided clock sync)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_clock_synced;
};

/**
 * Signals in message Quaternion.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_quaternion_t {
    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q0;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q1;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q2;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q3;
};

/**
 * Signals in message DeltaV.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_delta_v_t {
    /**
     * Range: -32768..32768 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -32768..32768 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -32768..32768 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t exponent;
};

/**
 * Signals in message RateOfTurn.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_rate_of_turn_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_x;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_y;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_z;
};

/**
 * Signals in message DeltaQ.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_delta_q_t {
    /**
     * Range: -32767..32767 (-1..1 m/sÂ²)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q1;

    /**
     * Range: -32767..32767 (-1..1 m/sÂ²)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q2;

    /**
     * Range: -32767..32767 (-1..1 m/sÂ²)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q3;

    /**
     * Range: -32767..32767 (-1..1 m/sÂ²)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q4;
};

/**
 * Signals in message Acceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_acceleration_t {
    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_x;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_y;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_z;
};

/**
 * Signals in message FreeAcceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_free_acceleration_t {
    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_x;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_y;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_z;
};

/**
 * Signals in message RateOfTurnHR.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_rate_of_turn_hr_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t hr_gyr_x;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t hr_gyr_y;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t hr_gyr_z;
};

/**
 * Signals in message AccelerationHR.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_acceleration_hr_t {
    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t hr_acc_x;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t hr_acc_y;

    /**
     * Range: -25600..25600 (-100..100 m/sÂ²)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t hr_acc_z;
};

/**
 * Signals in message MagneticField.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_magnetic_field_t {
    /**
     * Range: -32768..32768 (-32..32 a.u.)
     * Scale: 0.0009765625
     * Offset: 0
     */
    int16_t mag_x;

    /**
     * Range: -32768..32768 (-32..32 a.u)
     * Scale: 0.0009765625
     * Offset: 0
     */
    int16_t mag_y;

    /**
     * Range: -32768..32768 (-32..32 a.u)
     * Scale: 0.0009765625
     * Offset: 0
     */
    int16_t mag_z;
};

/**
 * Signals in message Temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_temperature_t {
    /**
     * Range: -10240..21760 (-40..85 degC)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t temperature;
};

/**
 * Signals in message BarometricPressure.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_barometric_pressure_t {
    /**
     * Range: 30000..125000 (30000..125000 Pa)
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure;
};

/**
 * Signals in message UTC.
 *
 * UTC Time in the following format YYMMDDhhmmss plus tenth of a milli second
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_utc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t year;

    /**
     * Range: 1..12 (1..12 M)
     * Scale: 1
     * Offset: 0
     */
    uint8_t month;

    /**
     * Range: 1..31 (1..31 D)
     * Scale: 1
     * Offset: 0
     */
    uint8_t day;

    /**
     * Range: 0..24 (0..24 h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hour;

    /**
     * Range: 0..60 (0..60 m)
     * Scale: 1
     * Offset: 0
     */
    uint8_t minute;

    /**
     * Range: 0..60 (0..60 s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t second;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t tenthms;
};

/**
 * Signals in message EulerAngles.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_euler_angles_t {
    /**
     * Range: -23040..23040 (-180..180 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -11520..11520 (-90..90 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -23040..23040 (-180..180 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message LatLon.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_lat_lon_t {
    /**
     * Range: -1509949440..1509949440 (-90..90 deg)
     * Scale: 5.9604644775e-08
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -1509949440..1509949440 (-180..180 deg)
     * Scale: 1.1920928955e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message AltitudeEllipsoid.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_altitude_ellipsoid_t {
    /**
     * Range: 0..1638400000 (0..50000 m)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    uint32_t alt_ellipsoid;
};

/**
 * Signals in message PositionEcef_X.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_position_ecef_x_t {
    /**
     * Range: -1664000000..1664000000 (-6500000..6500000 m)
     * Scale: 0.00390625
     * Offset: 0
     */
    int32_t position_ecef_x;
};

/**
 * Signals in message PositionEcef_Y.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_position_ecef_y_t {
    /**
     * Range: -1664000000..1664000000 (-6500000..6500000 m)
     * Scale: 0.00390625
     * Offset: 0
     */
    int32_t position_ecef_y;
};

/**
 * Signals in message PositionEcef_Z.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_position_ecef_z_t {
    /**
     * Range: -1664000000..1664000000 (-6500000..6500000 m)
     * Scale: 0.00390625
     * Offset: 0
     */
    int32_t position_ecef_z;
};

/**
 * Signals in message Velocity.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_velocity_t {
    /**
     * Range: -32000..32000 (-500..500 m/s)
     * Scale: 0.015625
     * Offset: 0
     */
    int16_t vel_x;

    /**
     * Range: -32000..32000 (-500..500 m/s)
     * Scale: 0.015625
     * Offset: 0
     */
    int16_t vel_y;

    /**
     * Range: -32000..32000 (-500..500 m/s)
     * Scale: 0.015625
     * Offset: 0
     */
    int16_t vel_z;
};

/**
 * Signals in message GnssReceiverStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_gnss_receiver_status_t {
    /**
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fix_type;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flags;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t num_svs;
};

/**
 * Signals in message GnssReceiverDop.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_gnss_receiver_dop_t {
    /**
     * Range: 0..10000 (0..100 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pdop;

    /**
     * Range: 0..10000 (0..100 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t tdop;

    /**
     * Range: 0..10000 (0..100 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t vdop;

    /**
     * Range: 0..10000 (0..100 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t hdop;
};

/**
 * Pack message Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_error_pack(
    uint8_t *dst_p,
    const struct xsens_error_t *src_p,
    size_t size);

/**
 * Unpack message Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_error_unpack(
    struct xsens_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Error.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_error_init(struct xsens_error_t *msg_p);

/**
 * Pack message Warning.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_warning_pack(
    uint8_t *dst_p,
    const struct xsens_warning_t *src_p,
    size_t size);

/**
 * Unpack message Warning.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_warning_unpack(
    struct xsens_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Warning.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_warning_init(struct xsens_warning_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_warning_warning_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_warning_warning_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_warning_warning_code_is_in_range(uint8_t value);

/**
 * Pack message SampleTime.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_sample_time_pack(
    uint8_t *dst_p,
    const struct xsens_sample_time_t *src_p,
    size_t size);

/**
 * Unpack message SampleTime.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_sample_time_unpack(
    struct xsens_sample_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SampleTime.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_sample_time_init(struct xsens_sample_time_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t xsens_sample_time_timestamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_sample_time_timestamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_sample_time_timestamp_is_in_range(uint32_t value);

/**
 * Pack message GroupCounter.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_group_counter_pack(
    uint8_t *dst_p,
    const struct xsens_group_counter_t *src_p,
    size_t size);

/**
 * Unpack message GroupCounter.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_group_counter_unpack(
    struct xsens_group_counter_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GroupCounter.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_group_counter_init(struct xsens_group_counter_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_group_counter_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_group_counter_counter_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_group_counter_counter_is_in_range(uint16_t value);

/**
 * Pack message StatusWord.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_status_word_pack(
    uint8_t *dst_p,
    const struct xsens_status_word_t *src_p,
    size_t size);

/**
 * Unpack message StatusWord.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_status_word_unpack(
    struct xsens_status_word_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from StatusWord.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_status_word_init(struct xsens_status_word_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_have_gnss_time_pulse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_have_gnss_time_pulse_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_have_gnss_time_pulse_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_rtk_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_rtk_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_rtk_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_filter_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_filter_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_filter_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_mag_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_mag_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_mag_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_retransmitted_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_retransmitted_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_retransmitted_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clipping_detected_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clipping_detected_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clipping_detected_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_interpolated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_interpolated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_interpolated_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_sync_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_sync_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_sync_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_sync_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_sync_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_sync_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_acc_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_acc_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_acc_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_acc_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_acc_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_acc_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_gyr_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_gyr_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_gyr_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_gyr_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_gyr_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_gyr_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_gyr_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_gyr_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_gyr_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_mag_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_mag_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_mag_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_clip_mag_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_clip_mag_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_clip_mag_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_self_test_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_self_test_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_self_test_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_orientation_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_orientation_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_orientation_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_gps_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_gps_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_gps_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_no_rotation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_no_rotation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_no_rotation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_representative_motion_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_representative_motion_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_representative_motion_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_status_word_external_clock_synced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_status_word_external_clock_synced_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_status_word_external_clock_synced_is_in_range(uint8_t value);

/**
 * Pack message Quaternion.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_quaternion_pack(
    uint8_t *dst_p,
    const struct xsens_quaternion_t *src_p,
    size_t size);

/**
 * Unpack message Quaternion.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_quaternion_unpack(
    struct xsens_quaternion_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Quaternion.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_quaternion_init(struct xsens_quaternion_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_quaternion_q0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_quaternion_q0_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_quaternion_q0_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_quaternion_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_quaternion_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_quaternion_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_quaternion_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_quaternion_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_quaternion_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_quaternion_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_quaternion_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_quaternion_q3_is_in_range(int16_t value);

/**
 * Pack message DeltaV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_delta_v_pack(
    uint8_t *dst_p,
    const struct xsens_delta_v_t *src_p,
    size_t size);

/**
 * Unpack message DeltaV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_delta_v_unpack(
    struct xsens_delta_v_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DeltaV.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_delta_v_init(struct xsens_delta_v_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_v_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_v_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_v_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_v_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_v_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_v_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_v_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_v_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_v_z_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_delta_v_exponent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_v_exponent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_v_exponent_is_in_range(uint8_t value);

/**
 * Pack message RateOfTurn.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_rate_of_turn_pack(
    uint8_t *dst_p,
    const struct xsens_rate_of_turn_t *src_p,
    size_t size);

/**
 * Unpack message RateOfTurn.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_rate_of_turn_unpack(
    struct xsens_rate_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RateOfTurn.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_rate_of_turn_init(struct xsens_rate_of_turn_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_gyr_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_gyr_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_gyr_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_gyr_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_gyr_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_gyr_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_gyr_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_gyr_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_gyr_z_is_in_range(int16_t value);

/**
 * Pack message DeltaQ.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_delta_q_pack(
    uint8_t *dst_p,
    const struct xsens_delta_q_t *src_p,
    size_t size);

/**
 * Unpack message DeltaQ.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_delta_q_unpack(
    struct xsens_delta_q_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DeltaQ.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_delta_q_init(struct xsens_delta_q_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_q_delta_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_q_delta_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_q_delta_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_q_delta_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_q_delta_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_q_delta_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_q_delta_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_q_delta_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_q_delta_q3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_delta_q_delta_q4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_delta_q_delta_q4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_delta_q_delta_q4_is_in_range(int16_t value);

/**
 * Pack message Acceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message Acceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_acceleration_unpack(
    struct xsens_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Acceleration.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_acceleration_init(struct xsens_acceleration_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_acc_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_acc_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_acc_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_acc_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_acc_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_acc_z_is_in_range(int16_t value);

/**
 * Pack message FreeAcceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_free_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_free_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message FreeAcceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_free_acceleration_unpack(
    struct xsens_free_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FreeAcceleration.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_free_acceleration_init(struct xsens_free_acceleration_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_free_acceleration_free_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_free_acceleration_free_acc_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_free_acceleration_free_acc_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_free_acceleration_free_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_free_acceleration_free_acc_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_free_acceleration_free_acc_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_free_acceleration_free_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_free_acceleration_free_acc_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_free_acceleration_free_acc_z_is_in_range(int16_t value);

/**
 * Pack message RateOfTurnHR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_rate_of_turn_hr_pack(
    uint8_t *dst_p,
    const struct xsens_rate_of_turn_hr_t *src_p,
    size_t size);

/**
 * Unpack message RateOfTurnHR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_rate_of_turn_hr_unpack(
    struct xsens_rate_of_turn_hr_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RateOfTurnHR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_rate_of_turn_hr_init(struct xsens_rate_of_turn_hr_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_hr_hr_gyr_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_hr_hr_gyr_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_hr_hr_gyr_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_hr_hr_gyr_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_hr_hr_gyr_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_hr_hr_gyr_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_rate_of_turn_hr_hr_gyr_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_rate_of_turn_hr_hr_gyr_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_rate_of_turn_hr_hr_gyr_z_is_in_range(int16_t value);

/**
 * Pack message AccelerationHR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_acceleration_hr_pack(
    uint8_t *dst_p,
    const struct xsens_acceleration_hr_t *src_p,
    size_t size);

/**
 * Unpack message AccelerationHR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_acceleration_hr_unpack(
    struct xsens_acceleration_hr_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AccelerationHR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_acceleration_hr_init(struct xsens_acceleration_hr_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_hr_hr_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_hr_hr_acc_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_hr_hr_acc_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_hr_hr_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_hr_hr_acc_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_hr_hr_acc_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_acceleration_hr_hr_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_acceleration_hr_hr_acc_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_acceleration_hr_hr_acc_z_is_in_range(int16_t value);

/**
 * Pack message MagneticField.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_magnetic_field_pack(
    uint8_t *dst_p,
    const struct xsens_magnetic_field_t *src_p,
    size_t size);

/**
 * Unpack message MagneticField.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_magnetic_field_unpack(
    struct xsens_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MagneticField.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_magnetic_field_init(struct xsens_magnetic_field_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_magnetic_field_mag_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_magnetic_field_mag_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_magnetic_field_mag_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_magnetic_field_mag_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_magnetic_field_mag_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_magnetic_field_mag_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_magnetic_field_mag_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_magnetic_field_mag_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_magnetic_field_mag_z_is_in_range(int16_t value);

/**
 * Pack message Temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_temperature_pack(
    uint8_t *dst_p,
    const struct xsens_temperature_t *src_p,
    size_t size);

/**
 * Unpack message Temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_temperature_unpack(
    struct xsens_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Temperature.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_temperature_init(struct xsens_temperature_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_temperature_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_temperature_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_temperature_temperature_is_in_range(int16_t value);

/**
 * Pack message BarometricPressure.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_barometric_pressure_pack(
    uint8_t *dst_p,
    const struct xsens_barometric_pressure_t *src_p,
    size_t size);

/**
 * Unpack message BarometricPressure.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_barometric_pressure_unpack(
    struct xsens_barometric_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BarometricPressure.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_barometric_pressure_init(struct xsens_barometric_pressure_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_barometric_pressure_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_barometric_pressure_pressure_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_barometric_pressure_pressure_is_in_range(int32_t value);

/**
 * Pack message UTC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_utc_pack(
    uint8_t *dst_p,
    const struct xsens_utc_t *src_p,
    size_t size);

/**
 * Unpack message UTC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_utc_unpack(
    struct xsens_utc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from UTC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_utc_init(struct xsens_utc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_day_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_day_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_day_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_hour_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_minute_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_minute_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_minute_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_utc_second_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_second_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_second_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_utc_tenthms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_utc_tenthms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_utc_tenthms_is_in_range(uint16_t value);

/**
 * Pack message EulerAngles.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_euler_angles_pack(
    uint8_t *dst_p,
    const struct xsens_euler_angles_t *src_p,
    size_t size);

/**
 * Unpack message EulerAngles.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_euler_angles_unpack(
    struct xsens_euler_angles_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EulerAngles.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_euler_angles_init(struct xsens_euler_angles_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_euler_angles_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_euler_angles_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_euler_angles_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_euler_angles_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_euler_angles_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_euler_angles_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_euler_angles_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_euler_angles_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_euler_angles_yaw_is_in_range(int16_t value);

/**
 * Pack message LatLon.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_lat_lon_pack(
    uint8_t *dst_p,
    const struct xsens_lat_lon_t *src_p,
    size_t size);

/**
 * Unpack message LatLon.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_lat_lon_unpack(
    struct xsens_lat_lon_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LatLon.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_lat_lon_init(struct xsens_lat_lon_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_lat_lon_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_lat_lon_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_lat_lon_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_lat_lon_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_lat_lon_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_lat_lon_longitude_is_in_range(int32_t value);

/**
 * Pack message AltitudeEllipsoid.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_altitude_ellipsoid_pack(
    uint8_t *dst_p,
    const struct xsens_altitude_ellipsoid_t *src_p,
    size_t size);

/**
 * Unpack message AltitudeEllipsoid.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_altitude_ellipsoid_unpack(
    struct xsens_altitude_ellipsoid_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AltitudeEllipsoid.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_altitude_ellipsoid_init(struct xsens_altitude_ellipsoid_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t xsens_altitude_ellipsoid_alt_ellipsoid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_altitude_ellipsoid_alt_ellipsoid_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_altitude_ellipsoid_alt_ellipsoid_is_in_range(uint32_t value);

/**
 * Pack message PositionEcef_X.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_position_ecef_x_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_x_t *src_p,
    size_t size);

/**
 * Unpack message PositionEcef_X.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_position_ecef_x_unpack(
    struct xsens_position_ecef_x_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PositionEcef_X.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_position_ecef_x_init(struct xsens_position_ecef_x_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_position_ecef_x_position_ecef_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_position_ecef_x_position_ecef_x_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_position_ecef_x_position_ecef_x_is_in_range(int32_t value);

/**
 * Pack message PositionEcef_Y.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_position_ecef_y_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_y_t *src_p,
    size_t size);

/**
 * Unpack message PositionEcef_Y.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_position_ecef_y_unpack(
    struct xsens_position_ecef_y_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PositionEcef_Y.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_position_ecef_y_init(struct xsens_position_ecef_y_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_position_ecef_y_position_ecef_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_position_ecef_y_position_ecef_y_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_position_ecef_y_position_ecef_y_is_in_range(int32_t value);

/**
 * Pack message PositionEcef_Z.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_position_ecef_z_pack(
    uint8_t *dst_p,
    const struct xsens_position_ecef_z_t *src_p,
    size_t size);

/**
 * Unpack message PositionEcef_Z.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_position_ecef_z_unpack(
    struct xsens_position_ecef_z_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PositionEcef_Z.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_position_ecef_z_init(struct xsens_position_ecef_z_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t xsens_position_ecef_z_position_ecef_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_position_ecef_z_position_ecef_z_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_position_ecef_z_position_ecef_z_is_in_range(int32_t value);

/**
 * Pack message Velocity.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_velocity_pack(
    uint8_t *dst_p,
    const struct xsens_velocity_t *src_p,
    size_t size);

/**
 * Unpack message Velocity.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_velocity_unpack(
    struct xsens_velocity_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Velocity.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_velocity_init(struct xsens_velocity_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_velocity_vel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_velocity_vel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_velocity_vel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_velocity_vel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_velocity_vel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_velocity_vel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_velocity_vel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_velocity_vel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_velocity_vel_z_is_in_range(int16_t value);

/**
 * Pack message GnssReceiverStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_gnss_receiver_status_pack(
    uint8_t *dst_p,
    const struct xsens_gnss_receiver_status_t *src_p,
    size_t size);

/**
 * Unpack message GnssReceiverStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_gnss_receiver_status_unpack(
    struct xsens_gnss_receiver_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GnssReceiverStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_gnss_receiver_status_init(struct xsens_gnss_receiver_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_gnss_receiver_status_fix_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_status_fix_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_status_fix_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_gnss_receiver_status_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_status_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_status_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_gnss_receiver_status_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_status_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_status_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_gnss_receiver_status_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_status_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_status_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_gnss_receiver_status_num_svs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_status_num_svs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_status_num_svs_is_in_range(uint8_t value);

/**
 * Pack message GnssReceiverDop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_gnss_receiver_dop_pack(
    uint8_t *dst_p,
    const struct xsens_gnss_receiver_dop_t *src_p,
    size_t size);

/**
 * Unpack message GnssReceiverDop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_gnss_receiver_dop_unpack(
    struct xsens_gnss_receiver_dop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GnssReceiverDop.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int xsens_gnss_receiver_dop_init(struct xsens_gnss_receiver_dop_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_gnss_receiver_dop_pdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_dop_pdop_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_dop_pdop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_gnss_receiver_dop_tdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_dop_tdop_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_dop_tdop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_gnss_receiver_dop_vdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_dop_vdop_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_dop_vdop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_gnss_receiver_dop_hdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_gnss_receiver_dop_hdop_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_gnss_receiver_dop_hdop_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
