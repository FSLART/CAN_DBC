/**
 * @file autonomous_bus.h
 *
 * @brief This header file was generated by cantools version 40.2.3 Tue Jul 15 16:53:56 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef AUTONOMOUS_BUS_H
#define AUTONOMOUS_BUS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_FRAME_ID (0x500u)
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_FRAME_ID (0x501u)
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_FRAME_ID (0x1414u)
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_FRAME_ID (0x1434u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_FRAME_ID (0x1454u)
#define AUTONOMOUS_BUS_VCU_HV500_FOC_FRAME_ID (0x1474u)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_FRAME_ID (0x1494u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_FRAME_ID (0x1894u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_AC_CURRENT_FRAME_ID (0x1754u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_BRAKE_CURRENT_FRAME_ID (0x1774u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_ERPM_FRAME_ID (0x1794u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_POSITION_FRAME_ID (0x17b4u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_CURRENT_FRAME_ID (0x17d4u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_BRAKE_CURRENT_FRAME_ID (0x17f4u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_CURRENT_FRAME_ID (0x1814u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_BRAKE_CURRENT_FRAME_ID (0x1834u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_CURRENT_FRAME_ID (0x1854u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_BRAKE_CURRENT_FRAME_ID (0x1874u)
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_FRAME_ID (0x502u)
#define AUTONOMOUS_BUS_ACU_HEARTBEAT_FRAME_ID (0x703u)
#define AUTONOMOUS_BUS_ASF_SIGNALS_FRAME_ID (0x511u)
#define AUTONOMOUS_BUS_NMT_FRAME_ID (0x00u)
#define AUTONOMOUS_BUS_RES_PDO_FRAME_ID (0x191u)
#define AUTONOMOUS_BUS_VCU_HEARTBEATS_FRAME_ID (0x2000u)
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_FRAME_ID (0x1461u)
#define AUTONOMOUS_BUS_DYNAMICS_REAR_FRAME_ID (0x280u)
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_FRAME_ID (0x2a0u)
#define AUTONOMOUS_BUS_RES_EM_FRAME_ID (0x91u)
#define AUTONOMOUS_BUS_MAXON_ERROR_FRAME_ID (0x85u)
#define AUTONOMOUS_BUS_ACU_ERROR_FRAME_ID (0x83u)
#define AUTONOMOUS_BUS_SYNC_FRAME_ID (0x80u)
#define AUTONOMOUS_BUS_BRAKE_LIGHT_FRAME_ID (0x437u)
#define AUTONOMOUS_BUS_MAXON_PDO_0_FRAME_ID (0x185u)
#define AUTONOMOUS_BUS_MAXON_PDO_3_FRAME_ID (0x385u)
#define AUTONOMOUS_BUS_MAXON_PDO_4_FRAME_ID (0x485u)
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_FRAME_ID (0x405u)
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_FRAME_ID (0x283u)

/* Frame lengths in bytes. */
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_LENGTH (8u)
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_LENGTH (6u)
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_FOC_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_AC_CURRENT_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_BRAKE_CURRENT_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_ERPM_LENGTH (4u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_POSITION_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_BRAKE_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_BRAKE_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_BRAKE_CURRENT_LENGTH (2u)
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_LENGTH (5u)
#define AUTONOMOUS_BUS_ACU_HEARTBEAT_LENGTH (1u)
#define AUTONOMOUS_BUS_ASF_SIGNALS_LENGTH (8u)
#define AUTONOMOUS_BUS_NMT_LENGTH (2u)
#define AUTONOMOUS_BUS_RES_PDO_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_HEARTBEATS_LENGTH (8u)
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_LENGTH (8u)
#define AUTONOMOUS_BUS_DYNAMICS_REAR_LENGTH (8u)
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_LENGTH (8u)
#define AUTONOMOUS_BUS_RES_EM_LENGTH (8u)
#define AUTONOMOUS_BUS_MAXON_ERROR_LENGTH (8u)
#define AUTONOMOUS_BUS_ACU_ERROR_LENGTH (8u)
#define AUTONOMOUS_BUS_SYNC_LENGTH (8u)
#define AUTONOMOUS_BUS_BRAKE_LIGHT_LENGTH (8u)
#define AUTONOMOUS_BUS_MAXON_PDO_0_LENGTH (8u)
#define AUTONOMOUS_BUS_MAXON_PDO_3_LENGTH (8u)
#define AUTONOMOUS_BUS_MAXON_PDO_4_LENGTH (8u)
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_LENGTH (8u)
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_LENGTH (8u)

/* Extended or standard frame types. */
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_FOC_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_AC_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_BRAKE_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_ERPM_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_POSITION_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_BRAKE_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_BRAKE_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_BRAKE_CURRENT_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_ACU_HEARTBEAT_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_ASF_SIGNALS_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_NMT_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_RES_PDO_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_VCU_HEARTBEATS_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_IS_EXTENDED (1)
#define AUTONOMOUS_BUS_DYNAMICS_REAR_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_RES_EM_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_MAXON_ERROR_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_ACU_ERROR_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_SYNC_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_BRAKE_LIGHT_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_MAXON_PDO_0_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_MAXON_PDO_3_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_MAXON_PDO_4_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_IS_EXTENDED (0)
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_NO_FAULT_CHOICE (0u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_OVERVOLTAGE___THE_INPUT_VOLTAGE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (1u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_UNDERVOLTAGE___THE_INPUT_VOLTAGE_IS_LOWER_THAN_THE_SET_MINIMUM_CHOICE (2u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_DRV_ERROR___TRANSISTOR_OR_TRANSISTOR_DRIVE_ERROR_CHOICE (3u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_ABSOLUTE_MAX_OVERCURRENT___THE_AC_CURRENT_IS_HIGHER_THAN_THE_SET_ABSOLUTE_MAXIMUM_CURRENT_CHOICE (4u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_CONTROLLER_OVERTEMPERATURE___THE_CONTROLLER_TEMPERATURE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (5u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_MOTOR_OVERTEMPERATURE___THE_MOTOR_TEMPERATURE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (6u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_SENSOR_WIRE_FAULT___SOMETHING_WENT_WRONG_WITH_THE_SENSOR_DIFFERENTIAL_SIGNALS_CHOICE (7u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_SENSOR_GENERAL_FAULT___AN_ERROR_OCCURRED_WHILE_PROCESSING_THE_SENSOR_SIGNALS_CHOICE (8u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_CAN_COMMAND_ERROR___CAN_MESSAGE_RECEIVED_CONTAINS_PARAMETER_OUT_OF_BOUNDARIES_CHOICE (9u)
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_ANALOG_INPUT_ERROR_____REDUNDANT_OUTPUT_OUT_OF_RANGE_CHOICE (10u)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_4_OUTPUT_4_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_4_OUTPUT_4_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_3_OUTPUT_3_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_3_OUTPUT_3_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_2_OUTPUT_2_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_2_OUTPUT_2_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_1_OUTPUT_1_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_1_OUTPUT_1_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_4_INPUT_4_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_4_INPUT_4_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_3_INPUT_3_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_3_INPUT_3_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_2_INPUT_2_ENABLED_0_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_2_INPUT_2_ENABLED_1_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_1_INPUT_1_DISABLED_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_1_INPUT_1_ENABLED_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_DRIVE_DISABLED_CHOICE (0u)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_DRIVE_ENABLED_CHOICE (1u)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_TEMP_LIMIT_MOTOR_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_TEMP_LIMIT_MOTOR_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_ACCEL_LIMIT_MOTOR_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_ACCEL_LIMIT_MOTOR_ACCELERATION_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_INPUT_VOLTAGE_LIMIT_INPUT_VOLTAGE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_INPUT_VOLTAGE_LIMIT_INPUT_VOLTAGE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_TEMP_LIMIT_IGBT_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_TEMP_LIMIT_IGBT_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_ACCEL_LIMIT_IGBT_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_0_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_ACCEL_LIMIT_IGBT_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_1_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_LIMIT_DRIVE_ENABLE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_LIMIT_DRIVE_ENABLE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_DC_CURRENT_LIMIT_DC_CURRENT_LIMIT_ACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DC_CURRENT_LIMIT_DC_CURRENT_LIMIT_INACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_CAPACITOR_TEMP_LIMIT_CAPACITOR_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_CAPACITOR_TEMP_LIMIT_CAPACITOR_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_POWER_LIMIT_POWER_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_POWER_LIMIT_POWER_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MAX_LIMIT_RPM_MAXIMUM_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MAX_LIMIT_RPM_MAXIMUM_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MIN_LIMIT_RPM_MINIMUM_LIMIT_INACTIVE_CHOICE (0)
#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MIN_LIMIT_RPM_MINIMUM_LIMIT_ACTIVE_CHOICE (1)

#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_DRIVE_NOT_ALLOWED_CHOICE (0u)
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_DRIVE_ALLOWED_CHOICE (1u)

/* Frame Names. */
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_NAME "AS_DynamicsDL_1"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_NAME "AS_DynamicsDL_2"
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_NAME "VCU_HV500_ERPM_DUTY_VOLTAGE"
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_NAME "VCU_HV500_AC_DC_current"
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_NAME "VCU_HV500_Temperatures"
#define AUTONOMOUS_BUS_VCU_HV500_FOC_NAME "VCU_HV500_FOC"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_NAME "VCU_HV500_MISC"
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_NAME "VCU_HV500_SetDriveEnable"
#define AUTONOMOUS_BUS_VCU_HV500_SET_AC_CURRENT_NAME "VCU_HV500_SetAcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_BRAKE_CURRENT_NAME "VCU_HV500_SetBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_ERPM_NAME "VCU_HV500_SetERPM"
#define AUTONOMOUS_BUS_VCU_HV500_SET_POSITION_NAME "VCU_HV500_SetPosition"
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_CURRENT_NAME "VCU_HV500_SetRelCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_BRAKE_CURRENT_NAME "VCU_HV500_SetRelBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_CURRENT_NAME "VCU_HV500_SetMaxAcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_BRAKE_CURRENT_NAME "VCU_HV500_SetMaxAcBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_CURRENT_NAME "VCU_HV500_SetMaxDcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_BRAKE_CURRENT_NAME "VCU_HV500_SetMaxDcBrakeCurrent"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_NAME "AS_System_Status"
#define AUTONOMOUS_BUS_ACU_HEARTBEAT_NAME "ACU_HEARTBEAT"
#define AUTONOMOUS_BUS_ASF_SIGNALS_NAME "ASF_SIGNALS"
#define AUTONOMOUS_BUS_NMT_NAME "NMT"
#define AUTONOMOUS_BUS_RES_PDO_NAME "RES_PDO"
#define AUTONOMOUS_BUS_VCU_HEARTBEATS_NAME "VCU_Heartbeats"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_NAME "VCU_TCU_Contactors"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_NAME "Dynamics_REAR"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_NAME "Dynamics_FRONT"
#define AUTONOMOUS_BUS_RES_EM_NAME "RES_EM"
#define AUTONOMOUS_BUS_MAXON_ERROR_NAME "MAXON_Error"
#define AUTONOMOUS_BUS_ACU_ERROR_NAME "ACU_ERROR"
#define AUTONOMOUS_BUS_SYNC_NAME "SYNC"
#define AUTONOMOUS_BUS_BRAKE_LIGHT_NAME "BrakeLight"
#define AUTONOMOUS_BUS_MAXON_PDO_0_NAME "MAXON_PDO_0"
#define AUTONOMOUS_BUS_MAXON_PDO_3_NAME "MAXON_PDO_3"
#define AUTONOMOUS_BUS_MAXON_PDO_4_NAME "MAXON_PDO_4"
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_NAME "MAXON_PDO_3_RX"
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_NAME "ACU_PDO_TX_2"

/* Signal Names. */
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_SPEED_ACTUAL_NAME "Speed_Actual"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_SPEED_TARGET_NAME "Speed_Target"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_STEERING_ANGLE_ACTUAL_NAME "Steering_Angle_Actual"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_STEERING_ANGLE_TARGET_NAME "Steering_Angle_Target"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_BRAKE_HYDRAULIC_ACTUAL_NAME "Brake_Hydraulic_Actual"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_BRAKE_HYDRAULIC_TARGET_NAME "Brake_Hydraulic_Target"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_MOTOR_MOMENT_ACTUAL_NAME "Motor_Moment_Actual"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_1_MOTOR_MOMENT_TARGET_NAME "Motor_Moment_Target"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_ACCELARATION_LONGITUDINAL_NAME "Accelaration_Longitudinal"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_ACCELARATION_LATERAL_NAME "Accelaration_Lateral"
#define AUTONOMOUS_BUS_AS_DYNAMICS_DL_2_YAW_RATE_NAME "Yaw_Rate"
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_ERPM_NAME "Actual_ERPM"
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_DUTY_NAME "Actual_Duty"
#define AUTONOMOUS_BUS_VCU_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_INPUT_VOLTAGE_NAME "Actual_InputVoltage"
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_ACTUAL_AC_CURRENT_NAME "Actual_ACCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_AC_DC_CURRENT_ACTUAL_DC_CURRENT_NAME "Actual_DCCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_TEMP_CONTROLLER_NAME "Actual_TempController"
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_TEMP_MOTOR_NAME "Actual_TempMotor"
#define AUTONOMOUS_BUS_VCU_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_NAME "Actual_FaultCode"
#define AUTONOMOUS_BUS_VCU_HV500_FOC_ACTUAL_FOC_ID_NAME "Actual_FOC_id"
#define AUTONOMOUS_BUS_VCU_HV500_FOC_ACTUAL_FOC_IQ_NAME "Actual_FOC_iq"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_ACTUAL_THROTTLE_NAME "Actual_Throttle"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_ACTUAL_BRAKE_NAME "Actual_Brake"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_4_NAME "Digital_output_4"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_3_NAME "Digital_output_3"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_2_NAME "Digital_output_2"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_OUTPUT_1_NAME "Digital_output_1"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_4_NAME "Digital_input_4"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_3_NAME "Digital_input_3"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_2_NAME "Digital_input_2"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DIGITAL_INPUT_1_NAME "Digital_input_1"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_NAME "Drive_enable"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_TEMP_LIMIT_NAME "Motor_temp_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_MOTOR_ACCEL_LIMIT_NAME "Motor_accel_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_INPUT_VOLTAGE_LIMIT_NAME "Input_voltage_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_TEMP_LIMIT_NAME "IGBT_temp_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_IGBT_ACCEL_LIMIT_NAME "IGBT_accel_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DRIVE_ENABLE_LIMIT_NAME "Drive_enable_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_DC_CURRENT_LIMIT_NAME "DC_current_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_CAPACITOR_TEMP_LIMIT_NAME "Capacitor_temp_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_POWER_LIMIT_NAME "Power_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MAX_LIMIT_NAME "RPM_max_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_RPM_MIN_LIMIT_NAME "RPM_min_limit"
#define AUTONOMOUS_BUS_VCU_HV500_MISC_CAN_MAP_VERSION_NAME "CAN_map_version"
#define AUTONOMOUS_BUS_VCU_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_NAME "CMD_DriveEnable"
#define AUTONOMOUS_BUS_VCU_HV500_SET_AC_CURRENT_CMD_TARGET_AC_CURRENT_NAME "CMD_TargetAcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_BRAKE_CURRENT_CMD_TARGET_BRAKE_CURRENT_NAME "CMD_TargetBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_ERPM_CMD_TARGET_SPEED_NAME "CMD_TargetSpeed"
#define AUTONOMOUS_BUS_VCU_HV500_SET_POSITION_CMD_TARGET_POSITION_NAME "CMD_TargetPosition"
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_CURRENT_CMD_TARGET_RELATIVE_CURRENT_NAME "CMD_TargetRelativeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_REL_BRAKE_CURRENT_CMD_TARGE_RELATIVE_BRAKE_CURRENT_NAME "CMD_TargeRelativeBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_CURRENT_CMD_MAX_AC_CURRENT_NAME "CMD_MaxAcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_AC_BRAKE_CURRENT_CMD_MAX_AC_BRAKE_CURRENT_NAME "CMD_MaxAcBrakeCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_CURRENT_CMD_MAX_DC_CURRENT_NAME "CMD_MaxDcCurrent"
#define AUTONOMOUS_BUS_VCU_HV500_SET_MAX_DC_BRAKE_CURRENT_CMD_MAX_DC_BRAKE_CURRENT_NAME "CMD_MaxDcBrakeCurrent"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_AS_STATE_NAME "AS_State"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_EBS_STATE_NAME "EBS_State"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_AMI_STATE_NAME "AMI_State"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_STEARING_STATE_NAME "Stearing_State"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_SERVICE_BRAKE_STATE_NAME "Service_Brake_State"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_LAP_COUNTER_NAME "Lap_Counter"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "Cones_Count_Actual"
#define AUTONOMOUS_BUS_AS_SYSTEM_STATUS_CONES_COUNT_ALL_NAME "Cones_Count_All"
#define AUTONOMOUS_BUS_ACU_HEARTBEAT_STATE_NAME "STATE"
#define AUTONOMOUS_BUS_ASF_SIGNALS_PNEUMATIC_BRAKING_EBS_FRONT_NAME "Pneumatic_Braking_EBS_FRONT"
#define AUTONOMOUS_BUS_ASF_SIGNALS_PNEUMATIC_BRAKING_BRAKE_FRONT_NAME "Pneumatic_Braking_BRAKE_FRONT"
#define AUTONOMOUS_BUS_ASF_SIGNALS_PNEUMATIC_BRAKING_EBS_BACK_NAME "Pneumatic_Braking_EBS_BACK"
#define AUTONOMOUS_BUS_ASF_SIGNALS_PNEUMATIC_BRAKING_BRAKE_BACK_NAME "Pneumatic_Braking_BRAKE_BACK"
#define AUTONOMOUS_BUS_NMT_STATE_NAME "State"
#define AUTONOMOUS_BUS_NMT_TARGET_NODE_NAME "Target_Node"
#define AUTONOMOUS_BUS_RES_PDO_BUTTON_STATE_NAME "Button_State"
#define AUTONOMOUS_BUS_VCU_HEARTBEATS_HB_NAME "HB"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_CONTACTORS_STATE_NAME "Contactors_State"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_CONTACTORS_ERROR_NAME "Contactors_Error"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_AUTONOMOUS_IGNITION_NAME "Autonomous_Ignition"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_PRE_CHARGE_NAME "Pre_Charge"
#define AUTONOMOUS_BUS_VCU_TCU_CONTACTORS_TCU_STATE_NAME "TCU_State"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_WHEEL_SPEED_RL_NAME "Wheel_Speed_RL"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_WHEEL_SPEED_RR_NAME "Wheel_Speed_RR"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_SUSPENSIO_POSITION_RL_NAME "Suspensio_Position_RL"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_SUSPENSIO_POSITION_RR_NAME "Suspensio_Position_RR"
#define AUTONOMOUS_BUS_DYNAMICS_REAR_DYNAMICS_STATE_NAME "Dynamics_State"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_WHEEL_SPEED_FL_NAME "Wheel_Speed_FL"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_WHEEL_SPEED_FR_NAME "Wheel_Speed_FR"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_SUSPENSIO_POSITION_FL_NAME "Suspensio_Position_FL"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_SUSPENSIO_POSITION_FR_NAME "Suspensio_Position_FR"
#define AUTONOMOUS_BUS_DYNAMICS_FRONT_DYNAMICS_STATE_NAME "Dynamics_State"
#define AUTONOMOUS_BUS_RES_EM_ERROR_STATE_NAME "ERROR_State"
#define AUTONOMOUS_BUS_MAXON_ERROR_ERROR_STATE_NAME "ERROR_State"
#define AUTONOMOUS_BUS_ACU_ERROR_ERROR_STATE_NAME "ERROR_State"
#define AUTONOMOUS_BUS_SYNC_COUNTER_NAME "Counter"
#define AUTONOMOUS_BUS_BRAKE_LIGHT_REAR_BRAKE_PRESSURE_NAME "Rear_Brake_Pressure"
#define AUTONOMOUS_BUS_BRAKE_LIGHT_BRAKE_LIGHT_STATE_NAME "BrakeLight_State"
#define AUTONOMOUS_BUS_MAXON_PDO_0_STATUS_WORD_NAME "Status_Word"
#define AUTONOMOUS_BUS_MAXON_PDO_0_CONTROL_WORD_NAME "Control_Word"
#define AUTONOMOUS_BUS_MAXON_PDO_0_CURRENT_ACTUAL_NAME "Current_Actual"
#define AUTONOMOUS_BUS_MAXON_PDO_3_STATUS_WORD_NAME "Status_Word"
#define AUTONOMOUS_BUS_MAXON_PDO_3_POSITION_ACTUAL_VALUE_NAME "Position_Actual_Value"
#define AUTONOMOUS_BUS_MAXON_PDO_3_TORQUE_ACTUAL_VALUE_NAME "Torque_Actual_Value"
#define AUTONOMOUS_BUS_MAXON_PDO_4_STATUS_WORD_NAME "STATUS_WORD"
#define AUTONOMOUS_BUS_MAXON_PDO_4_VELOCICTY_ACTUAL_NAME "Velocicty_Actual"
#define AUTONOMOUS_BUS_MAXON_PDO_4_PWM_DUTY_CICLE_ACTUAL_NAME "PWM_DutyCicle_Actual"
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_CONTROL_WORD_NAME "Control_Word"
#define AUTONOMOUS_BUS_MAXON_PDO_3_RX_TARGET_POSITION_NAME "Target_Position"
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_HYDRA_FRONT_BRAKE_NAME "Hydra_Front_Brake"
#define AUTONOMOUS_BUS_ACU_PDO_TX_2_STATUS_NAME "Status"

/**
 * Signals in message AS_DynamicsDL_1.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_as_dynamics_dl_1_t {
    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -128..127 (-64..63.5  )
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -128..127 (-64..63.5  )
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: 0..255 (0..255  )
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydraulic_actual;

    /**
     * Range: 0..255 (0..255  )
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydraulic_target;

    /**
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message AS_DynamicsDL_2.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_as_dynamics_dl_2_t {
    /**
     * Range: -32768..32767 (-63.9959..63.994 m/s^2)
     * Scale: 0.001953
     * Offset: 0
     */
    int16_t accelaration_longitudinal;

    /**
     * Range: -32768..32767 (-63.9959..63.994 m/s^2)
     * Scale: 0.001953
     * Offset: 0
     */
    int16_t accelaration_lateral;

    /**
     * Range: -32768..32767 (-256.016..256.009  /s)
     * Scale: 0.007813
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Signals in message VCU_HV500_ERPM_DUTY_VOLTAGE.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_erpm_duty_voltage_t {
    /**
     * Range: -214748000..214748000 (-214748000..214748000 ERPM)
     * Scale: 1
     * Offset: 0
     */
    int32_t actual_erpm;

    /**
     * Range: -32760..32760 (-3276..3276 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_duty;

    /**
     * Range: -32768..32767 (-32768..32767 V)
     * Scale: 1
     * Offset: 0
     */
    int16_t actual_input_voltage;
};

/**
 * Signals in message VCU_HV500_AC_DC_current.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_ac_dc_current_t {
    /**
     * Range: -32760..32760 (-3276..3276 Apk)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_ac_current;

    /**
     * Range: -32760..32760 (-3276..3276 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_dc_current;
};

/**
 * Signals in message VCU_HV500_Temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_temperatures_t {
    /**
     * Range: -32760..32760 (-3276..3276 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_temp_controller;

    /**
     * Range: -32760..32760 (-3276..3276 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_temp_motor;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t actual_fault_code;
};

/**
 * Signals in message VCU_HV500_FOC.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_foc_t {
    /**
     * Range: -360000..360000 (-3600..3600 Apk)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t actual_foc_id;

    /**
     * Range: -360000..360000 (-3600..3600 Apk)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t actual_foc_iq;
};

/**
 * Signals in message VCU_HV500_MISC.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_misc_t {
    /**
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t actual_throttle;

    /**
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t actual_brake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_output_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_output_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_output_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_output_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_input_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_input_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_input_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t digital_input_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_accel_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t input_voltage_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t igbt_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t igbt_accel_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t drive_enable_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t dc_current_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t capacitor_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t power_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rpm_max_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rpm_min_limit;

    /**
     * Range: 0..255 (0..25.5 Version)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t can_map_version;
};

/**
 * Signals in message VCU_HV500_SetDriveEnable.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_drive_enable_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmd_drive_enable;
};

/**
 * Signals in message VCU_HV500_SetAcCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_ac_current_t {
    /**
     * Range: -10000..10000 (-1000..1000 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_ac_current;
};

/**
 * Signals in message VCU_HV500_SetBrakeCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_brake_current_t {
    /**
     * Range: 0..10000 (0..1000 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_brake_current;
};

/**
 * Signals in message VCU_HV500_SetERPM.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_erpm_t {
    /**
     * Range: -2147480000..2147480000 (-2147480000..2147480000 ERPM)
     * Scale: 1
     * Offset: 0
     */
    int32_t cmd_target_speed;
};

/**
 * Signals in message VCU_HV500_SetPosition.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_position_t {
    /**
     * Range: 0..3600 (0..360 degree)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_position;
};

/**
 * Signals in message VCU_HV500_SetRelCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_rel_current_t {
    /**
     * Range: -1000..1000 (-100..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_relative_current;
};

/**
 * Signals in message VCU_HV500_SetRelBrakeCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_rel_brake_current_t {
    /**
     * Range: 0..1000 (0..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_targe_relative_brake_current;
};

/**
 * Signals in message VCU_HV500_SetMaxAcCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_max_ac_current_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_ac_current;
};

/**
 * Signals in message VCU_HV500_SetMaxAcBrakeCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_max_ac_brake_current_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_ac_brake_current;
};

/**
 * Signals in message VCU_HV500_SetMaxDcCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_max_dc_current_t {
    /**
     * Range: 0..3500 (0..350 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_dc_current;
};

/**
 * Signals in message VCU_HV500_SetMaxDcBrakeCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_hv500_set_max_dc_brake_current_t {
    /**
     * Range: 0..3500 (0..350 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_dc_brake_current;
};

/**
 * Signals in message AS_System_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_as_system_status_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t stearing_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_state;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_all;
};

/**
 * Signals in message ACU_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_acu_heartbeat_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;
};

/**
 * Signals in message ASF_SIGNALS.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_asf_signals_t {
    /**
     * Range: 0..65535 (0..655350 Bar)
     * Scale: 10
     * Offset: 0
     */
    uint16_t pneumatic_braking_ebs_front;

    /**
     * Range: 0..65535 (0..655350 Bar)
     * Scale: 10
     * Offset: 0
     */
    uint16_t pneumatic_braking_brake_front;

    /**
     * Range: 0..65535 (0..655350 Bar)
     * Scale: 10
     * Offset: 0
     */
    uint16_t pneumatic_braking_ebs_back;

    /**
     * Range: 0..65535 (0..655350 Bar)
     * Scale: 10
     * Offset: 0
     */
    uint16_t pneumatic_braking_brake_back;
};

/**
 * Signals in message NMT.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_nmt_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t target_node;
};

/**
 * Signals in message RES_PDO.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_res_pdo_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_state;
};

/**
 * Signals in message VCU_Heartbeats.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_heartbeats_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t hb;
};

/**
 * Signals in message VCU_TCU_Contactors.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_vcu_tcu_contactors_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t contactors_state;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t contactors_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t autonomous_ignition;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pre_charge;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tcu_state;
};

/**
 * Signals in message Dynamics_REAR.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_dynamics_rear_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_rr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t suspensio_position_rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t suspensio_position_rr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dynamics_state;
};

/**
 * Signals in message Dynamics_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_dynamics_front_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t suspensio_position_fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t suspensio_position_fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dynamics_state;
};

/**
 * Signals in message RES_EM.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_res_em_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_state;
};

/**
 * Signals in message MAXON_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_maxon_error_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_state;
};

/**
 * Signals in message ACU_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_acu_error_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_state;
};

/**
 * Signals in message SYNC.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_sync_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;
};

/**
 * Signals in message BrakeLight.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_brake_light_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rear_brake_pressure;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_light_state;
};

/**
 * Signals in message MAXON_PDO_0.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_maxon_pdo_0_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t control_word;

    /**
     * Range: 0..4294970000 (0..4294970000 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t current_actual;
};

/**
 * Signals in message MAXON_PDO_3.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_maxon_pdo_3_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: 0..4294970000 (0..4294970000 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t position_actual_value;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_actual_value;
};

/**
 * Signals in message MAXON_PDO_4.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_maxon_pdo_4_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: 0..4294970000 (0..4294970000 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t velocicty_actual;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwm_duty_cicle_actual;
};

/**
 * Signals in message MAXON_PDO_3_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_maxon_pdo_3_rx_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t control_word;

    /**
     * Range: 0..4294970000 (0..4294970000 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t target_position;
};

/**
 * Signals in message ACU_PDO_TX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_bus_acu_pdo_tx_2_t {
    /**
     * Range: 0..4294970000 (0..4294970000 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t hydra_front_brake;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Pack message AS_DynamicsDL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_as_dynamics_dl_1_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_as_dynamics_dl_1_t *src_p,
    size_t size);

/**
 * Unpack message AS_DynamicsDL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_as_dynamics_dl_1_unpack(
    struct autonomous_bus_as_dynamics_dl_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AS_DynamicsDL_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_as_dynamics_dl_1_init(struct autonomous_bus_as_dynamics_dl_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_dynamics_dl_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_dynamics_dl_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_as_dynamics_dl_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_as_dynamics_dl_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_dynamics_dl_1_brake_hydraulic_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_brake_hydraulic_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_brake_hydraulic_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_dynamics_dl_1_brake_hydraulic_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_brake_hydraulic_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_brake_hydraulic_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_as_dynamics_dl_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_as_dynamics_dl_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message AS_DynamicsDL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_as_dynamics_dl_2_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_as_dynamics_dl_2_t *src_p,
    size_t size);

/**
 * Unpack message AS_DynamicsDL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_as_dynamics_dl_2_unpack(
    struct autonomous_bus_as_dynamics_dl_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AS_DynamicsDL_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_as_dynamics_dl_2_init(struct autonomous_bus_as_dynamics_dl_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_as_dynamics_dl_2_accelaration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_2_accelaration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_2_accelaration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_as_dynamics_dl_2_accelaration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_2_accelaration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_2_accelaration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_as_dynamics_dl_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_dynamics_dl_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_dynamics_dl_2_yaw_rate_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_erpm_duty_voltage_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_erpm_duty_voltage_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_erpm_duty_voltage_unpack(
    struct autonomous_bus_vcu_hv500_erpm_duty_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_erpm_duty_voltage_init(struct autonomous_bus_vcu_hv500_erpm_duty_voltage_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_erpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_erpm_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_erpm_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_duty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_duty_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_duty_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_input_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_input_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_erpm_duty_voltage_actual_input_voltage_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_AC_DC_current.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_ac_dc_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_ac_dc_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_AC_DC_current.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_ac_dc_current_unpack(
    struct autonomous_bus_vcu_hv500_ac_dc_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_AC_DC_current.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_ac_dc_current_init(struct autonomous_bus_vcu_hv500_ac_dc_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_ac_dc_current_actual_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_ac_dc_current_actual_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_ac_dc_current_actual_ac_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_ac_dc_current_actual_dc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_ac_dc_current_actual_dc_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_ac_dc_current_actual_dc_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_Temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_temperatures_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_Temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_temperatures_unpack(
    struct autonomous_bus_vcu_hv500_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_Temperatures.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_temperatures_init(struct autonomous_bus_vcu_hv500_temperatures_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_temperatures_actual_temp_controller_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_temperatures_actual_temp_controller_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_temperatures_actual_temp_controller_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_temperatures_actual_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_temperatures_actual_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_temperatures_actual_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_hv500_temperatures_actual_fault_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_temperatures_actual_fault_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_temperatures_actual_fault_code_is_in_range(uint8_t value);

/**
 * Pack message VCU_HV500_FOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_foc_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_foc_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_FOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_foc_unpack(
    struct autonomous_bus_vcu_hv500_foc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_FOC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_foc_init(struct autonomous_bus_vcu_hv500_foc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t autonomous_bus_vcu_hv500_foc_actual_foc_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_foc_actual_foc_id_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_foc_actual_foc_id_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t autonomous_bus_vcu_hv500_foc_actual_foc_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_foc_actual_foc_iq_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_foc_actual_foc_iq_is_in_range(int32_t value);

/**
 * Pack message VCU_HV500_MISC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_misc_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_misc_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_MISC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_misc_unpack(
    struct autonomous_bus_vcu_hv500_misc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_MISC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_misc_init(struct autonomous_bus_vcu_hv500_misc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_actual_throttle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_actual_throttle_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_actual_throttle_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_actual_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_actual_brake_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_actual_brake_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_output_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_output_4_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_output_4_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_output_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_output_3_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_output_3_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_output_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_output_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_output_2_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_output_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_output_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_output_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_input_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_input_4_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_input_4_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_input_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_input_3_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_input_3_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_input_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_input_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_input_2_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_digital_input_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_digital_input_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_digital_input_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_hv500_misc_drive_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_drive_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_drive_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_motor_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_motor_temp_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_motor_temp_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_motor_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_motor_accel_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_motor_accel_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_input_voltage_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_input_voltage_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_input_voltage_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_igbt_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_igbt_temp_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_igbt_temp_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_igbt_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_igbt_accel_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_igbt_accel_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_drive_enable_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_drive_enable_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_drive_enable_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_dc_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_dc_current_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_dc_current_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_capacitor_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_capacitor_temp_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_capacitor_temp_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_power_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_power_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_power_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_rpm_max_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_rpm_max_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_rpm_max_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_vcu_hv500_misc_rpm_min_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_rpm_min_limit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_rpm_min_limit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_hv500_misc_can_map_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_misc_can_map_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_misc_can_map_version_is_in_range(uint8_t value);

/**
 * Pack message VCU_HV500_SetDriveEnable.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_drive_enable_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_drive_enable_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetDriveEnable.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_drive_enable_unpack(
    struct autonomous_bus_vcu_hv500_set_drive_enable_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetDriveEnable.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_drive_enable_init(struct autonomous_bus_vcu_hv500_set_drive_enable_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_hv500_set_drive_enable_cmd_drive_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_drive_enable_cmd_drive_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_drive_enable_cmd_drive_enable_is_in_range(uint8_t value);

/**
 * Pack message VCU_HV500_SetAcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_ac_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_ac_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetAcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_ac_current_unpack(
    struct autonomous_bus_vcu_hv500_set_ac_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetAcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_ac_current_init(struct autonomous_bus_vcu_hv500_set_ac_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_ac_current_cmd_target_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_ac_current_cmd_target_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_ac_current_cmd_target_ac_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_brake_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_brake_current_unpack(
    struct autonomous_bus_vcu_hv500_set_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_brake_current_init(struct autonomous_bus_vcu_hv500_set_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_brake_current_cmd_target_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_brake_current_cmd_target_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_brake_current_cmd_target_brake_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetERPM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_erpm_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_erpm_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetERPM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_erpm_unpack(
    struct autonomous_bus_vcu_hv500_set_erpm_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetERPM.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_erpm_init(struct autonomous_bus_vcu_hv500_set_erpm_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t autonomous_bus_vcu_hv500_set_erpm_cmd_target_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_erpm_cmd_target_speed_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_erpm_cmd_target_speed_is_in_range(int32_t value);

/**
 * Pack message VCU_HV500_SetPosition.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_position_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_position_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetPosition.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_position_unpack(
    struct autonomous_bus_vcu_hv500_set_position_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetPosition.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_position_init(struct autonomous_bus_vcu_hv500_set_position_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_position_cmd_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_position_cmd_target_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_position_cmd_target_position_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetRelCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_rel_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_rel_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetRelCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_rel_current_unpack(
    struct autonomous_bus_vcu_hv500_set_rel_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetRelCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_rel_current_init(struct autonomous_bus_vcu_hv500_set_rel_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_rel_current_cmd_target_relative_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_rel_current_cmd_target_relative_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_rel_current_cmd_target_relative_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetRelBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_rel_brake_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_rel_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetRelBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_rel_brake_current_unpack(
    struct autonomous_bus_vcu_hv500_set_rel_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetRelBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_rel_brake_current_init(struct autonomous_bus_vcu_hv500_set_rel_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetMaxAcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_ac_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_max_ac_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetMaxAcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_ac_current_unpack(
    struct autonomous_bus_vcu_hv500_set_max_ac_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetMaxAcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_max_ac_current_init(struct autonomous_bus_vcu_hv500_set_max_ac_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_max_ac_current_cmd_max_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_max_ac_current_cmd_max_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_max_ac_current_cmd_max_ac_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetMaxAcBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_ac_brake_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_max_ac_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetMaxAcBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_ac_brake_current_unpack(
    struct autonomous_bus_vcu_hv500_set_max_ac_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetMaxAcBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_max_ac_brake_current_init(struct autonomous_bus_vcu_hv500_set_max_ac_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetMaxDcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_dc_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_max_dc_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetMaxDcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_dc_current_unpack(
    struct autonomous_bus_vcu_hv500_set_max_dc_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetMaxDcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_max_dc_current_init(struct autonomous_bus_vcu_hv500_set_max_dc_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_max_dc_current_cmd_max_dc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_max_dc_current_cmd_max_dc_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_max_dc_current_cmd_max_dc_current_is_in_range(int16_t value);

/**
 * Pack message VCU_HV500_SetMaxDcBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_dc_brake_current_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_hv500_set_max_dc_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message VCU_HV500_SetMaxDcBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_hv500_set_max_dc_brake_current_unpack(
    struct autonomous_bus_vcu_hv500_set_max_dc_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_HV500_SetMaxDcBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_hv500_set_max_dc_brake_current_init(struct autonomous_bus_vcu_hv500_set_max_dc_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_bus_vcu_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_is_in_range(int16_t value);

/**
 * Pack message AS_System_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_as_system_status_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_as_system_status_t *src_p,
    size_t size);

/**
 * Unpack message AS_System_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_as_system_status_unpack(
    struct autonomous_bus_as_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AS_System_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_as_system_status_init(struct autonomous_bus_as_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_bus_as_system_status_stearing_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_stearing_state_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_stearing_state_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_service_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_service_brake_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_service_brake_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_as_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_as_system_status_cones_count_all_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_as_system_status_cones_count_all_is_in_range(uint8_t value);

/**
 * Pack message ACU_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_acu_heartbeat_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_acu_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message ACU_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_acu_heartbeat_unpack(
    struct autonomous_bus_acu_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_HEARTBEAT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_acu_heartbeat_init(struct autonomous_bus_acu_heartbeat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_acu_heartbeat_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_acu_heartbeat_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_acu_heartbeat_state_is_in_range(uint8_t value);

/**
 * Pack message ASF_SIGNALS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_asf_signals_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_asf_signals_t *src_p,
    size_t size);

/**
 * Unpack message ASF_SIGNALS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_asf_signals_unpack(
    struct autonomous_bus_asf_signals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ASF_SIGNALS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_asf_signals_init(struct autonomous_bus_asf_signals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_asf_signals_pneumatic_braking_ebs_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_asf_signals_pneumatic_braking_ebs_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_asf_signals_pneumatic_braking_ebs_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_asf_signals_pneumatic_braking_brake_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_asf_signals_pneumatic_braking_brake_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_asf_signals_pneumatic_braking_brake_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_asf_signals_pneumatic_braking_ebs_back_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_asf_signals_pneumatic_braking_ebs_back_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_asf_signals_pneumatic_braking_ebs_back_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_asf_signals_pneumatic_braking_brake_back_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_asf_signals_pneumatic_braking_brake_back_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_asf_signals_pneumatic_braking_brake_back_is_in_range(uint16_t value);

/**
 * Pack message NMT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_nmt_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_nmt_t *src_p,
    size_t size);

/**
 * Unpack message NMT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_nmt_unpack(
    struct autonomous_bus_nmt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NMT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_nmt_init(struct autonomous_bus_nmt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_nmt_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_nmt_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_nmt_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_nmt_target_node_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_nmt_target_node_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_nmt_target_node_is_in_range(uint8_t value);

/**
 * Pack message RES_PDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_res_pdo_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_res_pdo_t *src_p,
    size_t size);

/**
 * Unpack message RES_PDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_res_pdo_unpack(
    struct autonomous_bus_res_pdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RES_PDO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_res_pdo_init(struct autonomous_bus_res_pdo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_res_pdo_button_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_res_pdo_button_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_res_pdo_button_state_is_in_range(uint8_t value);

/**
 * Pack message VCU_Heartbeats.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_heartbeats_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_heartbeats_t *src_p,
    size_t size);

/**
 * Unpack message VCU_Heartbeats.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_heartbeats_unpack(
    struct autonomous_bus_vcu_heartbeats_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_Heartbeats.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_heartbeats_init(struct autonomous_bus_vcu_heartbeats_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_heartbeats_hb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_heartbeats_hb_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_heartbeats_hb_is_in_range(uint8_t value);

/**
 * Pack message VCU_TCU_Contactors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_vcu_tcu_contactors_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_vcu_tcu_contactors_t *src_p,
    size_t size);

/**
 * Unpack message VCU_TCU_Contactors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_vcu_tcu_contactors_unpack(
    struct autonomous_bus_vcu_tcu_contactors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_TCU_Contactors.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_vcu_tcu_contactors_init(struct autonomous_bus_vcu_tcu_contactors_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_tcu_contactors_contactors_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_tcu_contactors_contactors_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_tcu_contactors_contactors_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_tcu_contactors_contactors_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_tcu_contactors_contactors_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_tcu_contactors_contactors_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_tcu_contactors_autonomous_ignition_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_tcu_contactors_autonomous_ignition_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_tcu_contactors_autonomous_ignition_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_tcu_contactors_pre_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_tcu_contactors_pre_charge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_tcu_contactors_pre_charge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_vcu_tcu_contactors_tcu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_vcu_tcu_contactors_tcu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_vcu_tcu_contactors_tcu_state_is_in_range(uint8_t value);

/**
 * Pack message Dynamics_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_dynamics_rear_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_dynamics_rear_t *src_p,
    size_t size);

/**
 * Unpack message Dynamics_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_dynamics_rear_unpack(
    struct autonomous_bus_dynamics_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Dynamics_REAR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_dynamics_rear_init(struct autonomous_bus_dynamics_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_rear_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_rear_wheel_speed_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_rear_wheel_speed_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_rear_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_rear_wheel_speed_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_rear_wheel_speed_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_rear_suspensio_position_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_rear_suspensio_position_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_rear_suspensio_position_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_rear_suspensio_position_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_rear_suspensio_position_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_rear_suspensio_position_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_rear_dynamics_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_rear_dynamics_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_rear_dynamics_state_is_in_range(uint8_t value);

/**
 * Pack message Dynamics_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_dynamics_front_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_dynamics_front_t *src_p,
    size_t size);

/**
 * Unpack message Dynamics_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_dynamics_front_unpack(
    struct autonomous_bus_dynamics_front_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Dynamics_FRONT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_dynamics_front_init(struct autonomous_bus_dynamics_front_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_front_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_front_wheel_speed_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_front_wheel_speed_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_front_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_front_wheel_speed_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_front_wheel_speed_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_front_suspensio_position_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_front_suspensio_position_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_front_suspensio_position_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_front_suspensio_position_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_front_suspensio_position_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_front_suspensio_position_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_dynamics_front_dynamics_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_dynamics_front_dynamics_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_dynamics_front_dynamics_state_is_in_range(uint8_t value);

/**
 * Pack message RES_EM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_res_em_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_res_em_t *src_p,
    size_t size);

/**
 * Unpack message RES_EM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_res_em_unpack(
    struct autonomous_bus_res_em_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RES_EM.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_res_em_init(struct autonomous_bus_res_em_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_res_em_error_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_res_em_error_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_res_em_error_state_is_in_range(uint8_t value);

/**
 * Pack message MAXON_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_maxon_error_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_maxon_error_t *src_p,
    size_t size);

/**
 * Unpack message MAXON_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_maxon_error_unpack(
    struct autonomous_bus_maxon_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MAXON_Error.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_maxon_error_init(struct autonomous_bus_maxon_error_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_maxon_error_error_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_error_error_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_error_error_state_is_in_range(uint8_t value);

/**
 * Pack message ACU_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_acu_error_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_acu_error_t *src_p,
    size_t size);

/**
 * Unpack message ACU_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_acu_error_unpack(
    struct autonomous_bus_acu_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_ERROR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_acu_error_init(struct autonomous_bus_acu_error_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_acu_error_error_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_acu_error_error_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_acu_error_error_state_is_in_range(uint8_t value);

/**
 * Pack message SYNC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_sync_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_sync_t *src_p,
    size_t size);

/**
 * Unpack message SYNC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_sync_unpack(
    struct autonomous_bus_sync_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SYNC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_sync_init(struct autonomous_bus_sync_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_sync_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_sync_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_sync_counter_is_in_range(uint8_t value);

/**
 * Pack message BrakeLight.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_brake_light_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_brake_light_t *src_p,
    size_t size);

/**
 * Unpack message BrakeLight.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_brake_light_unpack(
    struct autonomous_bus_brake_light_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BrakeLight.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_brake_light_init(struct autonomous_bus_brake_light_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_brake_light_rear_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_brake_light_rear_brake_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_brake_light_rear_brake_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_brake_light_brake_light_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_brake_light_brake_light_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_brake_light_brake_light_state_is_in_range(uint8_t value);

/**
 * Pack message MAXON_PDO_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_maxon_pdo_0_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_maxon_pdo_0_t *src_p,
    size_t size);

/**
 * Unpack message MAXON_PDO_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_maxon_pdo_0_unpack(
    struct autonomous_bus_maxon_pdo_0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MAXON_PDO_0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_maxon_pdo_0_init(struct autonomous_bus_maxon_pdo_0_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_0_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_0_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_0_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_0_control_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_0_control_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_0_control_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_bus_maxon_pdo_0_current_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_0_current_actual_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_0_current_actual_is_in_range(uint32_t value);

/**
 * Pack message MAXON_PDO_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_maxon_pdo_3_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_maxon_pdo_3_t *src_p,
    size_t size);

/**
 * Unpack message MAXON_PDO_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_maxon_pdo_3_unpack(
    struct autonomous_bus_maxon_pdo_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MAXON_PDO_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_maxon_pdo_3_init(struct autonomous_bus_maxon_pdo_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_3_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_3_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_3_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_bus_maxon_pdo_3_position_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_3_position_actual_value_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_3_position_actual_value_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_3_torque_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_3_torque_actual_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_3_torque_actual_value_is_in_range(uint16_t value);

/**
 * Pack message MAXON_PDO_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_maxon_pdo_4_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_maxon_pdo_4_t *src_p,
    size_t size);

/**
 * Unpack message MAXON_PDO_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_maxon_pdo_4_unpack(
    struct autonomous_bus_maxon_pdo_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MAXON_PDO_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_maxon_pdo_4_init(struct autonomous_bus_maxon_pdo_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_4_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_4_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_4_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_bus_maxon_pdo_4_velocicty_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_4_velocicty_actual_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_4_velocicty_actual_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_4_pwm_duty_cicle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_4_pwm_duty_cicle_actual_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_4_pwm_duty_cicle_actual_is_in_range(uint16_t value);

/**
 * Pack message MAXON_PDO_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_maxon_pdo_3_rx_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_maxon_pdo_3_rx_t *src_p,
    size_t size);

/**
 * Unpack message MAXON_PDO_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_maxon_pdo_3_rx_unpack(
    struct autonomous_bus_maxon_pdo_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MAXON_PDO_3_RX.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_maxon_pdo_3_rx_init(struct autonomous_bus_maxon_pdo_3_rx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t autonomous_bus_maxon_pdo_3_rx_control_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_3_rx_control_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_3_rx_control_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_bus_maxon_pdo_3_rx_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_maxon_pdo_3_rx_target_position_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_maxon_pdo_3_rx_target_position_is_in_range(uint32_t value);

/**
 * Pack message ACU_PDO_TX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_bus_acu_pdo_tx_2_pack(
    uint8_t *dst_p,
    const struct autonomous_bus_acu_pdo_tx_2_t *src_p,
    size_t size);

/**
 * Unpack message ACU_PDO_TX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_bus_acu_pdo_tx_2_unpack(
    struct autonomous_bus_acu_pdo_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_PDO_TX_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_bus_acu_pdo_tx_2_init(struct autonomous_bus_acu_pdo_tx_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_bus_acu_pdo_tx_2_hydra_front_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_acu_pdo_tx_2_hydra_front_brake_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_acu_pdo_tx_2_hydra_front_brake_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_bus_acu_pdo_tx_2_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_bus_acu_pdo_tx_2_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_bus_acu_pdo_tx_2_status_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
