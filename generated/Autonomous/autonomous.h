/**
 * @file autonomous.h
 *
 * @brief This header file was generated by cantools version 40.3.0 Tue Aug  5 18:41:20 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef AUTONOMOUS_H
#define AUTONOMOUS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_FRAME_ID (0x500u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define AUTONOMOUS_RES_FRAME_ID (0x191u)
#define AUTONOMOUS_ACU_SIGNALS_FRAME_ID (0x51u)
#define AUTONOMOUS_ACU_DEBUG_FRAME_ID (0x81u)
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)

/* Frame lengths in bytes. */
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_LENGTH (8u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_LENGTH (8u)
#define AUTONOMOUS_RES_LENGTH (8u)
#define AUTONOMOUS_ACU_SIGNALS_LENGTH (2u)
#define AUTONOMOUS_ACU_DEBUG_LENGTH (8u)
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_LENGTH (8u)

/* Extended or standard frame types. */
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_IS_EXTENDED (0)
#define AUTONOMOUS_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define AUTONOMOUS_RES_IS_EXTENDED (0)
#define AUTONOMOUS_ACU_SIGNALS_IS_EXTENDED (0)
#define AUTONOMOUS_ACU_DEBUG_IS_EXTENDED (0)
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_OFF_CHOICE (1u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_READY_CHOICE (2u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_DRIVING_CHOICE (3u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_EMERGENCY_CHOICE (4u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_FINISHED_CHOICE (5u)

#define AUTONOMOUS_DV_SYSTEM_STATUS_EBS_STATE_DEACTIVATED_CHOICE (1u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_EBS_STATE_INITIAL_CHECKUP_PASSED_CHOICE (2u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_EBS_STATE_ACTIVATED_CHOICE (3u)

#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_ACCELERATION_CHOICE (1u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_SKIDPAD_CHOICE (2u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_TRACKDRIVE_CHOICE (3u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_BRAKETEST_CHOICE (4u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_INSPECTION_CHOICE (5u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_AUTOCROSS_CHOICE (6u)

#define AUTONOMOUS_DV_SYSTEM_STATUS_ASB_DEACTIVATED_CHOICE (1u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_ASB_ENGAGED_CHOICE (2u)
#define AUTONOMOUS_DV_SYSTEM_STATUS_ASB_INITIAL_CHECKUP_CHOICE (3u)

#define AUTONOMOUS_RES_RES_EMERGENCY_CHOICE (0u)
#define AUTONOMOUS_RES_RES_GO_SIGNAL_1_CHOICE (5u)
#define AUTONOMOUS_RES_RES_GO_SIGNAL_2_CHOICE (7u)

#define AUTONOMOUS_ACU_SIGNALS_MS_MANUAL_CHOICE (1u)
#define AUTONOMOUS_ACU_SIGNALS_MS_ACCELERATION_CHOICE (2u)
#define AUTONOMOUS_ACU_SIGNALS_MS_SKIDPAD_CHOICE (3u)
#define AUTONOMOUS_ACU_SIGNALS_MS_TRACKDRIVE_CHOICE (4u)
#define AUTONOMOUS_ACU_SIGNALS_MS_BRAKE_TEST_CHOICE (5u)
#define AUTONOMOUS_ACU_SIGNALS_MS_AUTOCROSS_CHOICE (6u)

#define AUTONOMOUS_ACU_SIGNALS_IGN_OFF_CHOICE (0u)
#define AUTONOMOUS_ACU_SIGNALS_IGN_ON_CHOICE (1u)

#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_MISSION_SELECT_CHOICE (1u)
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_INITIAL_SEQUENCE_CHOICE (2u)
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_MANUAL_MODE_CHOICE (3u)
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_AUTONOMOUS_MODE_CHOICE (4u)
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_EMERGENCY_CHOICE (5u)
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_RESET_CHOICE (6u)

#define AUTONOMOUS_ACU_DEBUG_ASMS_OFF_CHOICE (0u)
#define AUTONOMOUS_ACU_DEBUG_ASMS_ON_CHOICE (1u)

#define AUTONOMOUS_ACU_DEBUG_ASSI_BLUE_OFF_CHOICE (0u)
#define AUTONOMOUS_ACU_DEBUG_ASSI_BLUE_ON_CHOICE (1u)

#define AUTONOMOUS_ACU_DEBUG_ASSI_YELLOW_OFF_CHOICE (0u)
#define AUTONOMOUS_ACU_DEBUG_ASSI_YELLOW_ON_CHOICE (1u)

/* Frame Names. */
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_NAME "DV_driving_dynamics_1"
#define AUTONOMOUS_DV_SYSTEM_STATUS_NAME "DV_SYSTEM_STATUS"
#define AUTONOMOUS_RES_NAME "RES"
#define AUTONOMOUS_ACU_SIGNALS_NAME "ACU_SIGNALS"
#define AUTONOMOUS_ACU_DEBUG_NAME "ACU_Debug"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_NAME "DV_DRIVING_DYNAMICS_2"

/* Signal Names. */
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_SPEED_ACTUAL_NAME "Speed_Actual"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_SPEED_TARGET_NAME "Speed_target"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_ACTUAL_NAME "Steering_angle_actual"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_TARGET_NAME "Steering_angle_target"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_BRAKE_HYDRAULIC_ACTUAL_NAME "Brake_hydraulic_actual"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_BRAKE_HYDRAULIC_TARGET_NAME "Brake_hydraulic_target"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_ACTUAL_NAME "Motor_moment_actual"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_TARGET_NAME "Motor_moment_target"
#define AUTONOMOUS_DV_SYSTEM_STATUS_AS_STATUS_NAME "AS_STATUS"
#define AUTONOMOUS_DV_SYSTEM_STATUS_EBS_STATE_NAME "EBS_STATE"
#define AUTONOMOUS_DV_SYSTEM_STATUS_AMI_NAME "AMI"
#define AUTONOMOUS_DV_SYSTEM_STATUS_STEERING_STATE_NAME "Steering_state"
#define AUTONOMOUS_DV_SYSTEM_STATUS_ASB_NAME "ASB"
#define AUTONOMOUS_DV_SYSTEM_STATUS_LAP_COUNTER_NAME "LAP_COUNTER"
#define AUTONOMOUS_DV_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "CONES_COUNT_ACTUAL"
#define AUTONOMOUS_DV_SYSTEM_STATUS_CONES_TOTAL_NAME "CONES_TOTAL"
#define AUTONOMOUS_RES_RES_NAME "RES"
#define AUTONOMOUS_ACU_SIGNALS_MS_NAME "MS"
#define AUTONOMOUS_ACU_SIGNALS_IGN_NAME "IGN"
#define AUTONOMOUS_ACU_DEBUG_HYDRAULIC_BRAKE_PRESSURE_1_NAME "Hydraulic_brake_pressure_1"
#define AUTONOMOUS_ACU_DEBUG_HYDRAULIC_BRAKE_PRESSURE_2_NAME "Hydraulic_brake_pressure_2"
#define AUTONOMOUS_ACU_DEBUG_ACU_STATE_NAME "ACU_STATE"
#define AUTONOMOUS_ACU_DEBUG_ASMS_NAME "ASMS"
#define AUTONOMOUS_ACU_DEBUG_ASSI_BLUE_NAME "ASSI_BLUE"
#define AUTONOMOUS_ACU_DEBUG_ASSI_YELLOW_NAME "ASSI_YELLOW"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_ACCELERATION_LONGITUDINAL_NAME "ACCELERATION_LONGITUDINAL"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_ACCELERATION_LATERAL_NAME "ACCELERATION_LATERAL"
#define AUTONOMOUS_DV_DRIVING_DYNAMICS_2_YAW_RATE_NAME "YAW_RATE"

/**
 * Signals in message DV_driving_dynamics_1.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_dv_driving_dynamics_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydraulic_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydraulic_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message DV_SYSTEM_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_total;
};

/**
 * Signals in message RES.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_res_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res;
};

/**
 * Signals in message ACU_SIGNALS.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_acu_signals_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ms;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ign;
};

/**
 * Signals in message ACU_Debug.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_acu_debug_t {
    /**
     * Range: 0..105 (0..10.5 BAR)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t hydraulic_brake_pressure_1;

    /**
     * Range: 0..100 (0..10 BAR)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t hydraulic_brake_pressure_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t acu_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow;
};

/**
 * Signals in message DV_DRIVING_DYNAMICS_2.
 *
 * All signal values are as on the CAN bus.
 */
struct autonomous_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Pack message DV_driving_dynamics_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct autonomous_dv_driving_dynamics_1_t *src_p,
    size_t size);

/**
 * Unpack message DV_driving_dynamics_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_dv_driving_dynamics_1_unpack(
    struct autonomous_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_driving_dynamics_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_dv_driving_dynamics_1_init(struct autonomous_dv_driving_dynamics_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_driving_dynamics_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_driving_dynamics_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_dv_driving_dynamics_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_dv_driving_dynamics_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_driving_dynamics_1_brake_hydraulic_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_brake_hydraulic_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_brake_hydraulic_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_driving_dynamics_1_brake_hydraulic_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_brake_hydraulic_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_brake_hydraulic_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_dv_driving_dynamics_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t autonomous_dv_driving_dynamics_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_dv_system_status_pack(
    uint8_t *dst_p,
    const struct autonomous_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_dv_system_status_unpack(
    struct autonomous_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_SYSTEM_STATUS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_dv_system_status_init(struct autonomous_dv_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_as_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_as_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_as_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_ami_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_ami_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_ami_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_asb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_asb_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_asb_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t autonomous_dv_system_status_cones_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_system_status_cones_total_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_system_status_cones_total_is_in_range(uint32_t value);

/**
 * Pack message RES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_res_pack(
    uint8_t *dst_p,
    const struct autonomous_res_t *src_p,
    size_t size);

/**
 * Unpack message RES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_res_unpack(
    struct autonomous_res_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RES.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_res_init(struct autonomous_res_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_res_res_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_res_res_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_res_res_is_in_range(uint8_t value);

/**
 * Pack message ACU_SIGNALS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_acu_signals_pack(
    uint8_t *dst_p,
    const struct autonomous_acu_signals_t *src_p,
    size_t size);

/**
 * Unpack message ACU_SIGNALS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_acu_signals_unpack(
    struct autonomous_acu_signals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_SIGNALS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_acu_signals_init(struct autonomous_acu_signals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_signals_ms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_signals_ms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_signals_ms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_signals_ign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_signals_ign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_signals_ign_is_in_range(uint8_t value);

/**
 * Pack message ACU_Debug.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_acu_debug_pack(
    uint8_t *dst_p,
    const struct autonomous_acu_debug_t *src_p,
    size_t size);

/**
 * Unpack message ACU_Debug.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_acu_debug_unpack(
    struct autonomous_acu_debug_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACU_Debug.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_acu_debug_init(struct autonomous_acu_debug_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_hydraulic_brake_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_hydraulic_brake_pressure_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_hydraulic_brake_pressure_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_hydraulic_brake_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_hydraulic_brake_pressure_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_hydraulic_brake_pressure_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_acu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_acu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_acu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_asms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_asms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_asms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_assi_blue_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_assi_blue_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_assi_blue_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t autonomous_acu_debug_assi_yellow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_acu_debug_assi_yellow_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_acu_debug_assi_yellow_is_in_range(uint8_t value);

/**
 * Pack message DV_DRIVING_DYNAMICS_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int autonomous_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct autonomous_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message DV_DRIVING_DYNAMICS_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int autonomous_dv_driving_dynamics_2_unpack(
    struct autonomous_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_DRIVING_DYNAMICS_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int autonomous_dv_driving_dynamics_2_init(struct autonomous_dv_driving_dynamics_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t autonomous_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double autonomous_dv_driving_dynamics_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool autonomous_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value);


#ifdef __cplusplus
}
#endif

#endif
