/**
 * @file data_dbc.h
 *
 * @brief This header file was generated by cantools version 40.5.0 Tue Aug 12 14:16:21 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef DATA_DBC_H
#define DATA_DBC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define DATA_DBC_VCU__FRAME_ID (0x100u)
#define DATA_DBC_VCU_1_FRAME_ID (0x101u)
#define DATA_DBC_VCU_2_FRAME_ID (0x102u)
#define DATA_DBC_VCU_3_FRAME_ID (0x103u)
#define DATA_DBC_VCU_4_FRAME_ID (0x104u)
#define DATA_DBC_IMU__FRAME_ID (0x60u)
#define DATA_DBC_IMU_1_FRAME_ID (0x61u)
#define DATA_DBC_DYN_FRONT_SIG1_FRAME_ID (0x446u)
#define DATA_DBC_DYN_FRONT_SIG2_FRAME_ID (0x456u)
#define DATA_DBC_DATA_LOGGER_FRAME_ID (0x180u)
#define DATA_DBC_VCU_5_FRAME_ID (0x105u)
#define DATA_DBC_DYN_REAR_SIG1_FRAME_ID (0x546u)
#define DATA_DBC_DYN_REAR_SIG2_FRAME_ID (0x556u)

/* Frame lengths in bytes. */
#define DATA_DBC_VCU__LENGTH (8u)
#define DATA_DBC_VCU_1_LENGTH (8u)
#define DATA_DBC_VCU_2_LENGTH (8u)
#define DATA_DBC_VCU_3_LENGTH (8u)
#define DATA_DBC_VCU_4_LENGTH (8u)
#define DATA_DBC_IMU__LENGTH (8u)
#define DATA_DBC_IMU_1_LENGTH (8u)
#define DATA_DBC_DYN_FRONT_SIG1_LENGTH (6u)
#define DATA_DBC_DYN_FRONT_SIG2_LENGTH (4u)
#define DATA_DBC_DATA_LOGGER_LENGTH (8u)
#define DATA_DBC_VCU_5_LENGTH (1u)
#define DATA_DBC_DYN_REAR_SIG1_LENGTH (6u)
#define DATA_DBC_DYN_REAR_SIG2_LENGTH (4u)

/* Extended or standard frame types. */
#define DATA_DBC_VCU__IS_EXTENDED (0)
#define DATA_DBC_VCU_1_IS_EXTENDED (0)
#define DATA_DBC_VCU_2_IS_EXTENDED (0)
#define DATA_DBC_VCU_3_IS_EXTENDED (0)
#define DATA_DBC_VCU_4_IS_EXTENDED (0)
#define DATA_DBC_IMU__IS_EXTENDED (0)
#define DATA_DBC_IMU_1_IS_EXTENDED (0)
#define DATA_DBC_DYN_FRONT_SIG1_IS_EXTENDED (0)
#define DATA_DBC_DYN_FRONT_SIG2_IS_EXTENDED (0)
#define DATA_DBC_DATA_LOGGER_IS_EXTENDED (0)
#define DATA_DBC_VCU_5_IS_EXTENDED (0)
#define DATA_DBC_DYN_REAR_SIG1_IS_EXTENDED (0)
#define DATA_DBC_DYN_REAR_SIG2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define DATA_DBC_VCU__NAME "VCU_"
#define DATA_DBC_VCU_1_NAME "VCU_1"
#define DATA_DBC_VCU_2_NAME "VCU_2"
#define DATA_DBC_VCU_3_NAME "VCU_3"
#define DATA_DBC_VCU_4_NAME "VCU_4"
#define DATA_DBC_IMU__NAME "IMU_"
#define DATA_DBC_IMU_1_NAME "IMU_1"
#define DATA_DBC_DYN_FRONT_SIG1_NAME "DYN_FRONT_SIG1"
#define DATA_DBC_DYN_FRONT_SIG2_NAME "DYN_FRONT_SIG2"
#define DATA_DBC_DATA_LOGGER_NAME "DataLogger"
#define DATA_DBC_VCU_5_NAME "VCU_5"
#define DATA_DBC_DYN_REAR_SIG1_NAME "DYN_REAR_SIG1"
#define DATA_DBC_DYN_REAR_SIG2_NAME "DYN_REAR_SIG2"

/* Signal Names. */
#define DATA_DBC_VCU__APPS_NAME "APPS"
#define DATA_DBC_VCU__BPS_NAME "BPS"
#define DATA_DBC_VCU__TRGT_POWER_NAME "TRGT_Power"
#define DATA_DBC_VCU__CNSM_POWER_NAME "CNSM_Power"
#define DATA_DBC_VCU_1_INV_TEMPERATURE_NAME "INV_Temperature"
#define DATA_DBC_VCU_1_MOTOR_TEMPERATURE_NAME "Motor_Temperature"
#define DATA_DBC_VCU_1_BMS_VOLTAGE_NAME "BMS_Voltage"
#define DATA_DBC_VCU_1_SOC_HV_NAME "SOC_HV"
#define DATA_DBC_VCU_2_INV_FAULTS_NAME "INV_Faults"
#define DATA_DBC_VCU_2_LMT1_NAME "LMT1"
#define DATA_DBC_VCU_2_LMT2_NAME "LMT2"
#define DATA_DBC_VCU_2_VCU_STATE_NAME "VCU_State"
#define DATA_DBC_VCU_2_APPS_ERROR_NAME "APPS_Error"
#define DATA_DBC_VCU_2_POWER_PLAN_NAME "Power_Plan"
#define DATA_DBC_VCU_3_INV_VOLTAGE_NAME "INV_Voltage"
#define DATA_DBC_VCU_3_RPM_NAME "RPM"
#define DATA_DBC_VCU_3_IGN_NAME "IGN"
#define DATA_DBC_VCU_3_R2_D_NAME "R2D"
#define DATA_DBC_VCU_4_TCU_STATE_NAME "TCU_State"
#define DATA_DBC_VCU_4_ACU_STATE_NAME "ACU_State"
#define DATA_DBC_VCU_4_ALC_STATE_NAME "ALC_State"
#define DATA_DBC_IMU__ACCEL_X_INT_NAME "AccelX_int"
#define DATA_DBC_IMU__ACCEL_Y_DEC_NAME "AccelY_dec"
#define DATA_DBC_IMU__ACCEL_Z_INT_NAME "AccelZ_int"
#define DATA_DBC_IMU__HEATBIT_NAME "Heatbit"
#define DATA_DBC_IMU_1_ROLL_INT_NAME "roll_int"
#define DATA_DBC_IMU_1_PITCH_DEC_NAME "pitch_dec"
#define DATA_DBC_IMU_1_YAW_INT_NAME "yaw_int"
#define DATA_DBC_IMU_1_HEARTBIT_NAME "Heartbit"
#define DATA_DBC_DYN_FRONT_SIG1_ST_ANGLE_NAME "ST_ANGLE"
#define DATA_DBC_DYN_FRONT_SIG1_SUSP_R_NAME "SUSP_R"
#define DATA_DBC_DYN_FRONT_SIG1_SUSP_L_NAME "SUSP_L"
#define DATA_DBC_DYN_FRONT_SIG2_SPD_LEFT_NAME "SPD_LEFT"
#define DATA_DBC_DYN_FRONT_SIG2_SPD_RIGHT_NAME "SPD_RIGHT"
#define DATA_DBC_DATA_LOGGER_DL_STATE_NAME "DL_state"
#define DATA_DBC_DATA_LOGGER_RECORDING_STATE_NAME "Recording_State"
#define DATA_DBC_VCU_5_BRAKE_PRESSURE_FRONT_NAME "brake_pressure_front"
#define DATA_DBC_DYN_REAR_SIG1_BRK_PRESS_NAME "BRK_PRESS"
#define DATA_DBC_DYN_REAR_SIG1_SUSP_R_NAME "SUSP_R"
#define DATA_DBC_DYN_REAR_SIG1_SUSP_L_NAME "SUSP_L"
#define DATA_DBC_DYN_REAR_SIG2_SPD_LEFT_NAME "SPD_LEFT"
#define DATA_DBC_DYN_REAR_SIG2_SPD_RIGHT_NAME "SPD_RIGHT"

/**
 * Signals in message VCU_.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu__t {
    /**
     * Accelerator_Pedal_Position_Sense
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps;

    /**
     * Brake_Pressure
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bps;

    /**
     * Target_Power
     *
     * Range: 0..85000 (0..85000 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t trgt_power;

    /**
     * Current Consumed Power
     *
     * Range: 0..85000 (0..85000 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t cnsm_power;
};

/**
 * Signals in message VCU_1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_1_t {
    /**
     * Inverter_Temperature
     *
     * Range: -40..260 (0..300 ï¿½C)
     * Scale: 1
     * Offset: 40
     */
    uint16_t inv_temperature;

    /**
     * Motor_Temperature
     *
     * Range: -40..60 (0..100 ï¿½C)
     * Scale: 1
     * Offset: 40
     */
    uint16_t motor_temperature;

    /**
     * bms_voltage
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage;

    /**
     * SOC_HV
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_hv;
};

/**
 * Signals in message VCU_2.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_2_t {
    /**
     * INVERSOR_ERROR
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inv_faults;

    /**
     * RPM_Power_Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt1;

    /**
     * Current_Limit_Motor_Temp
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt2;

    /**
     * VCU_State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_state;

    /**
     * APPS_Error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_error;

    /**
     * Power_Plan_Switch_Volante
     *
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_plan;
};

/**
 * Signals in message VCU_3.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_3_t {
    /**
     * DC_Link_Inverter_Voltage
     *
     * Range: 0..620 (0..620 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inv_voltage;

    /**
     * RPM
     *
     * Range: 0..7000 (0..7000 RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rpm;

    /**
     * Ignition
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ign;

    /**
     * Ready to drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2_d;
};

/**
 * Signals in message VCU_4.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tcu_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t acu_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t alc_state;
};

/**
 * Signals in message IMU_.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_imu__t {
    /**
     * X Acceleration Integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t accel_x_int;

    /**
     * Y Acceleration Integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t accel_y_dec;

    /**
     * Z Acceleration Integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_z_int;

    /**
     * Heartbit
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t heatbit;
};

/**
 * Signals in message IMU_1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_imu_1_t {
    /**
     * roll integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t roll_int;

    /**
     * pitch integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t pitch_dec;

    /**
     * yaw integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t yaw_int;

    /**
     * Heartbit (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t heartbit;
};

/**
 * Signals in message DYN_FRONT_SIG1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dyn_front_sig1_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t st_angle;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t susp_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t susp_l;
};

/**
 * Signals in message DYN_FRONT_SIG2.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dyn_front_sig2_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t spd_left;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t spd_right;
};

/**
 * Signals in message DataLogger.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_data_logger_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dl_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t recording_state;
};

/**
 * Signals in message VCU_5.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_5_t {
    /**
     * Range: -
     * Scale: 0
     * Offset: 0
     */
    uint8_t brake_pressure_front;
};

/**
 * Signals in message DYN_REAR_SIG1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dyn_rear_sig1_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t brk_press;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t susp_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t susp_l;
};

/**
 * Signals in message DYN_REAR_SIG2.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dyn_rear_sig2_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t spd_left;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t spd_right;
};

/**
 * Pack message VCU_.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu__pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu__t *src_p,
    size_t size);

/**
 * Unpack message VCU_.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu__unpack(
    struct data_dbc_vcu__t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu__init(struct data_dbc_vcu__t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu__apps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__apps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__apps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu__bps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__bps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__bps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t data_dbc_vcu__trgt_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__trgt_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__trgt_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t data_dbc_vcu__cnsm_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__cnsm_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__cnsm_power_is_in_range(uint32_t value);

/**
 * Pack message VCU_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_1_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_1_t *src_p,
    size_t size);

/**
 * Unpack message VCU_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_1_unpack(
    struct data_dbc_vcu_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_1_init(struct data_dbc_vcu_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_inv_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_inv_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_inv_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_motor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_motor_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_motor_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_bms_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_bms_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_bms_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_1_soc_hv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_soc_hv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_soc_hv_is_in_range(uint8_t value);

/**
 * Pack message VCU_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_2_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_2_t *src_p,
    size_t size);

/**
 * Unpack message VCU_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_2_unpack(
    struct data_dbc_vcu_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_2_init(struct data_dbc_vcu_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_2_inv_faults_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_inv_faults_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_inv_faults_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_lmt1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_lmt1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_lmt1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_lmt2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_lmt2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_lmt2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_vcu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_vcu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_vcu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_apps_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_apps_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_apps_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_power_plan_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_power_plan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_power_plan_is_in_range(uint8_t value);

/**
 * Pack message VCU_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_3_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_3_t *src_p,
    size_t size);

/**
 * Unpack message VCU_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_3_unpack(
    struct data_dbc_vcu_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_3_init(struct data_dbc_vcu_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_3_inv_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_inv_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_inv_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_3_rpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_rpm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_rpm_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_3_ign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_ign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_ign_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_3_r2_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_r2_d_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_r2_d_is_in_range(uint8_t value);

/**
 * Pack message VCU_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_4_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_4_t *src_p,
    size_t size);

/**
 * Unpack message VCU_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_4_unpack(
    struct data_dbc_vcu_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_4_init(struct data_dbc_vcu_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_tcu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_tcu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_tcu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_acu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_acu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_acu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_alc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_alc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_alc_state_is_in_range(uint8_t value);

/**
 * Pack message IMU_.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_imu__pack(
    uint8_t *dst_p,
    const struct data_dbc_imu__t *src_p,
    size_t size);

/**
 * Unpack message IMU_.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_imu__unpack(
    struct data_dbc_imu__t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_imu__init(struct data_dbc_imu__t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu__accel_x_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_x_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_x_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu__accel_y_dec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_y_dec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_y_dec_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu__accel_z_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_z_int_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_z_int_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu__heatbit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__heatbit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__heatbit_is_in_range(uint8_t value);

/**
 * Pack message IMU_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_imu_1_pack(
    uint8_t *dst_p,
    const struct data_dbc_imu_1_t *src_p,
    size_t size);

/**
 * Unpack message IMU_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_imu_1_unpack(
    struct data_dbc_imu_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_imu_1_init(struct data_dbc_imu_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_roll_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_roll_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_roll_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_pitch_dec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_pitch_dec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_pitch_dec_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_yaw_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_yaw_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_yaw_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu_1_heartbit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_heartbit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_heartbit_is_in_range(uint8_t value);

/**
 * Pack message DYN_FRONT_SIG1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dyn_front_sig1_pack(
    uint8_t *dst_p,
    const struct data_dbc_dyn_front_sig1_t *src_p,
    size_t size);

/**
 * Unpack message DYN_FRONT_SIG1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dyn_front_sig1_unpack(
    struct data_dbc_dyn_front_sig1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DYN_FRONT_SIG1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dyn_front_sig1_init(struct data_dbc_dyn_front_sig1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t data_dbc_dyn_front_sig1_st_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_front_sig1_st_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_front_sig1_st_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_front_sig1_susp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_front_sig1_susp_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_front_sig1_susp_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_front_sig1_susp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_front_sig1_susp_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_front_sig1_susp_l_is_in_range(uint16_t value);

/**
 * Pack message DYN_FRONT_SIG2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dyn_front_sig2_pack(
    uint8_t *dst_p,
    const struct data_dbc_dyn_front_sig2_t *src_p,
    size_t size);

/**
 * Unpack message DYN_FRONT_SIG2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dyn_front_sig2_unpack(
    struct data_dbc_dyn_front_sig2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DYN_FRONT_SIG2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dyn_front_sig2_init(struct data_dbc_dyn_front_sig2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_front_sig2_spd_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_front_sig2_spd_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_front_sig2_spd_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_front_sig2_spd_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_front_sig2_spd_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_front_sig2_spd_right_is_in_range(uint16_t value);

/**
 * Pack message DataLogger.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_data_logger_pack(
    uint8_t *dst_p,
    const struct data_dbc_data_logger_t *src_p,
    size_t size);

/**
 * Unpack message DataLogger.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_data_logger_unpack(
    struct data_dbc_data_logger_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DataLogger.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_data_logger_init(struct data_dbc_data_logger_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_data_logger_dl_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_data_logger_dl_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_data_logger_dl_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_data_logger_recording_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_data_logger_recording_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_data_logger_recording_state_is_in_range(uint8_t value);

/**
 * Pack message VCU_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_5_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_5_t *src_p,
    size_t size);

/**
 * Unpack message VCU_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_5_unpack(
    struct data_dbc_vcu_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_5_init(struct data_dbc_vcu_5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_5_brake_pressure_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_5_brake_pressure_front_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_5_brake_pressure_front_is_in_range(uint8_t value);

/**
 * Pack message DYN_REAR_SIG1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dyn_rear_sig1_pack(
    uint8_t *dst_p,
    const struct data_dbc_dyn_rear_sig1_t *src_p,
    size_t size);

/**
 * Unpack message DYN_REAR_SIG1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dyn_rear_sig1_unpack(
    struct data_dbc_dyn_rear_sig1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DYN_REAR_SIG1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dyn_rear_sig1_init(struct data_dbc_dyn_rear_sig1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_rear_sig1_brk_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_rear_sig1_brk_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_rear_sig1_brk_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_rear_sig1_susp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_rear_sig1_susp_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_rear_sig1_susp_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_rear_sig1_susp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_rear_sig1_susp_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_rear_sig1_susp_l_is_in_range(uint16_t value);

/**
 * Pack message DYN_REAR_SIG2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dyn_rear_sig2_pack(
    uint8_t *dst_p,
    const struct data_dbc_dyn_rear_sig2_t *src_p,
    size_t size);

/**
 * Unpack message DYN_REAR_SIG2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dyn_rear_sig2_unpack(
    struct data_dbc_dyn_rear_sig2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DYN_REAR_SIG2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dyn_rear_sig2_init(struct data_dbc_dyn_rear_sig2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_rear_sig2_spd_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_rear_sig2_spd_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_rear_sig2_spd_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_dyn_rear_sig2_spd_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dyn_rear_sig2_spd_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dyn_rear_sig2_spd_right_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
