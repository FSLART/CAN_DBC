/**
 * @file hv500_can2_map_v23_sid.h
 *
 * @brief This header file was generated by cantools version 40.2.3 Sat Jul 26 01:58:43 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef HV500_CAN2_MAP_V23_SID_H
#define HV500_CAN2_MAP_V23_SID_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_FRAME_ID (0x14u)
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_FRAME_ID (0x34u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_FRAME_ID (0x54u)
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_FRAME_ID (0x74u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_FRAME_ID (0x94u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_FRAME_ID (0x494u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_FRAME_ID (0x354u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_FRAME_ID (0x374u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_FRAME_ID (0x394u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_FRAME_ID (0x3b4u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_FRAME_ID (0x3d4u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_FRAME_ID (0x3f4u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_FRAME_ID (0x414u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_FRAME_ID (0x434u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_FRAME_ID (0x454u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_FRAME_ID (0x474u)

/* Frame lengths in bytes. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_LENGTH (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_LENGTH (4u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_LENGTH (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_LENGTH (2u)

/* Extended or standard frame types. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_IS_EXTENDED (0)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_CYCLE_TIME_MS (100u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_CYCLE_TIME_MS (100u)

/* Signal choices. */
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_NO_FAULT_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_OVERVOLTAGE___THE_INPUT_VOLTAGE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (1u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_UNDERVOLTAGE___THE_INPUT_VOLTAGE_IS_LOWER_THAN_THE_SET_MINIMUM_CHOICE (2u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_DRV_ERROR___TRANSISTOR_OR_TRANSISTOR_DRIVE_ERROR_CHOICE (3u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_ABSOLUTE_MAX_OVERCURRENT___THE_AC_CURRENT_IS_HIGHER_THAN_THE_SET_ABSOLUTE_MAXIMUM_CURRENT_CHOICE (4u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_CONTROLLER_OVERTEMPERATURE___THE_CONTROLLER_TEMPERATURE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (5u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_MOTOR_OVERTEMPERATURE___THE_MOTOR_TEMPERATURE_IS_HIGHER_THAN_THE_SET_MAXIMUM_CHOICE (6u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_SENSOR_WIRE_FAULT___SOMETHING_WENT_WRONG_WITH_THE_SENSOR_DIFFERENTIAL_SIGNALS_CHOICE (7u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_SENSOR_GENERAL_FAULT___AN_ERROR_OCCURRED_WHILE_PROCESSING_THE_SENSOR_SIGNALS_CHOICE (8u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_CAN_COMMAND_ERROR___CAN_MESSAGE_RECEIVED_CONTAINS_PARAMETER_OUT_OF_BOUNDARIES_CHOICE (9u)
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_ANALOG_INPUT_ERROR_____REDUNDANT_OUTPUT_OUT_OF_RANGE_CHOICE (10u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_4_OUTPUT_4_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_4_OUTPUT_4_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_3_OUTPUT_3_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_3_OUTPUT_3_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_2_OUTPUT_2_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_2_OUTPUT_2_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_1_OUTPUT_1_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_1_OUTPUT_1_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_4_INPUT_4_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_4_INPUT_4_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_3_INPUT_3_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_3_INPUT_3_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_2_INPUT_2_ENABLED_0_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_2_INPUT_2_ENABLED_1_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_1_INPUT_1_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_1_INPUT_1_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_DRIVE_DISABLED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_DRIVE_ENABLED_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_TEMP_LIMIT_MOTOR_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_TEMP_LIMIT_MOTOR_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_ACCEL_LIMIT_MOTOR_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_ACCEL_LIMIT_MOTOR_ACCELERATION_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_INPUT_VOLTAGE_LIMIT_INPUT_VOLTAGE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_INPUT_VOLTAGE_LIMIT_INPUT_VOLTAGE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_TEMP_LIMIT_IGBT_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_TEMP_LIMIT_IGBT_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_ACCEL_LIMIT_IGBT_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_0_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_ACCEL_LIMIT_IGBT_ACCELERATION_TEMPERATURE_LIMIT_INACTIVE_1_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_LIMIT_DRIVE_ENABLE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_LIMIT_DRIVE_ENABLE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DC_CURRENT_LIMIT_DC_CURRENT_LIMIT_ACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DC_CURRENT_LIMIT_DC_CURRENT_LIMIT_INACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_CAPACITOR_TEMP_LIMIT_CAPACITOR_TEMPERATURE_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_CAPACITOR_TEMP_LIMIT_CAPACITOR_TEMPERATURE_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_POWER_LIMIT_POWER_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_POWER_LIMIT_POWER_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MAX_LIMIT_RPM_MAXIMUM_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MAX_LIMIT_RPM_MAXIMUM_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MIN_LIMIT_RPM_MINIMUM_LIMIT_INACTIVE_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MIN_LIMIT_RPM_MINIMUM_LIMIT_ACTIVE_CHOICE (1u)

#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_DRIVE_NOT_ALLOWED_CHOICE (0u)
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_DRIVE_ALLOWED_CHOICE (1u)

/* Frame Names. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_NAME "HV500_ERPM_DUTY_VOLTAGE"
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_NAME "HV500_AC_DC_current"
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_NAME "HV500_Temperatures"
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_NAME "HV500_FOC"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_NAME "HV500_MISC"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_NAME "HV500_SetDriveEnable"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_NAME "HV500_SetAcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_NAME "HV500_SetBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_NAME "HV500_SetERPM"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_NAME "HV500_SetPosition"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_NAME "HV500_SetRelCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_NAME "HV500_SetRelBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_NAME "HV500_SetMaxAcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_NAME "HV500_SetMaxAcBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_NAME "HV500_SetMaxDcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_NAME "HV500_SetMaxDcBrakeCurrent"

/* Signal Names. */
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_ERPM_NAME "Actual_ERPM"
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_DUTY_NAME "Actual_Duty"
#define HV500_CAN2_MAP_V23_SID_HV500_ERPM_DUTY_VOLTAGE_ACTUAL_INPUT_VOLTAGE_NAME "Actual_InputVoltage"
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_ACTUAL_AC_CURRENT_NAME "Actual_ACCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_AC_DC_CURRENT_ACTUAL_DC_CURRENT_NAME "Actual_DCCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_TEMP_CONTROLLER_NAME "Actual_TempController"
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_TEMP_MOTOR_NAME "Actual_TempMotor"
#define HV500_CAN2_MAP_V23_SID_HV500_TEMPERATURES_ACTUAL_FAULT_CODE_NAME "Actual_FaultCode"
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_ACTUAL_FOC_ID_NAME "Actual_FOC_id"
#define HV500_CAN2_MAP_V23_SID_HV500_FOC_ACTUAL_FOC_IQ_NAME "Actual_FOC_iq"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_ACTUAL_THROTTLE_NAME "Actual_Throttle"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_ACTUAL_BRAKE_NAME "Actual_Brake"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_4_NAME "Digital_output_4"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_3_NAME "Digital_output_3"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_2_NAME "Digital_output_2"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_OUTPUT_1_NAME "Digital_output_1"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_4_NAME "Digital_input_4"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_3_NAME "Digital_input_3"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_2_NAME "Digital_input_2"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DIGITAL_INPUT_1_NAME "Digital_input_1"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_NAME "Drive_enable"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_TEMP_LIMIT_NAME "Motor_temp_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_MOTOR_ACCEL_LIMIT_NAME "Motor_accel_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_INPUT_VOLTAGE_LIMIT_NAME "Input_voltage_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_TEMP_LIMIT_NAME "IGBT_temp_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_IGBT_ACCEL_LIMIT_NAME "IGBT_accel_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DRIVE_ENABLE_LIMIT_NAME "Drive_enable_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_DC_CURRENT_LIMIT_NAME "DC_current_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_CAPACITOR_TEMP_LIMIT_NAME "Capacitor_temp_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_POWER_LIMIT_NAME "Power_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MAX_LIMIT_NAME "RPM_max_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_RPM_MIN_LIMIT_NAME "RPM_min_limit"
#define HV500_CAN2_MAP_V23_SID_HV500_MISC_CAN_MAP_VERSION_NAME "CAN_map_version"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_DRIVE_ENABLE_CMD_DRIVE_ENABLE_NAME "CMD_DriveEnable"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_AC_CURRENT_CMD_TARGET_AC_CURRENT_NAME "CMD_TargetAcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_BRAKE_CURRENT_CMD_TARGET_BRAKE_CURRENT_NAME "CMD_TargetBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_ERPM_CMD_TARGET_SPEED_NAME "CMD_TargetSpeed"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_POSITION_CMD_TARGET_POSITION_NAME "CMD_TargetPosition"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_CURRENT_CMD_TARGET_RELATIVE_CURRENT_NAME "CMD_TargetRelativeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_REL_BRAKE_CURRENT_CMD_TARGE_RELATIVE_BRAKE_CURRENT_NAME "CMD_TargeRelativeBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_CURRENT_CMD_MAX_AC_CURRENT_NAME "CMD_MaxAcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_AC_BRAKE_CURRENT_CMD_MAX_AC_BRAKE_CURRENT_NAME "CMD_MaxAcBrakeCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_CURRENT_CMD_MAX_DC_CURRENT_NAME "CMD_MaxDcCurrent"
#define HV500_CAN2_MAP_V23_SID_HV500_SET_MAX_DC_BRAKE_CURRENT_CMD_MAX_DC_BRAKE_CURRENT_NAME "CMD_MaxDcBrakeCurrent"

/**
 * Signals in message HV500_ERPM_DUTY_VOLTAGE.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_t {
    /**
     * Electrical RPM
     * Equation: ERPM = Motor RPM * number of the motor pole pairs.
     *
     * Range: -214748000..214748000 (-214748000..214748000 ERPM)
     * Scale: 1
     * Offset: 0
     */
    int32_t actual_erpm;

    /**
     * The controller duty cycle. The sign of this value will represent whether the motor is running(positive) current or regenerating (negative) current.
     *
     * Range: -32760..32760 (-3276..3276 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_duty;

    /**
     * Input voltage is the DC voltage.
     *
     * Range: -32768..32767 (-32768..32767 V)
     * Scale: 1
     * Offset: 0
     */
    int16_t actual_input_voltage;
};

/**
 * Signals in message HV500_AC_DC_current.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_ac_dc_current_t {
    /**
     * The motor current. The sign of this value represents whether the motor is running(positive) current or regenerating (negative) current.
     *
     * Range: -32760..32760 (-3276..3276 Apk)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_ac_current;

    /**
     * DC Current: Current on DC side. The sign of this value represents whether the motor is running(positive) current or regenerating (negative) current.
     *
     * Range: -32760..32760 (-3276..3276 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_dc_current;
};

/**
 * Signals in message HV500_Temperatures.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_temperatures_t {
    /**
     * Temperature of the inverter semiconductors.
     *
     * Range: -32760..32760 (-3276..3276 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_temp_controller;

    /**
     * Temperature of the motor measured by the inverter.
     *
     * Range: -32760..32760 (-3276..3276 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t actual_temp_motor;

    /**
     * Fault codes.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t actual_fault_code;
};

/**
 * Signals in message HV500_FOC.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_foc_t {
    /**
     * FOC algorithm component Id.
     *
     * Range: -214748000000..214748000000 (-2147480000..2147480000 Apk)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t actual_foc_id;

    /**
     * FOC algorithm component Iq
     *
     * Range: -214748000000..214748000000 (-2147480000..2147480000 Apk)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t actual_foc_iq;
};

/**
 * Signals in message HV500_MISC.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_misc_t {
    /**
     * Throttle signal derived from analog inputs or CAN2.
     *
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t actual_throttle;

    /**
     * Brake signal derived from analog inputs or CAN2.
     *
     * Range: -128..127 (-128..127 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t actual_brake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_output_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_output_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_output_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_output_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_accel_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t input_voltage_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t igbt_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t igbt_accel_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_enable_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_current_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t capacitor_temp_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rpm_max_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rpm_min_limit;

    /**
     * Indicates the CAN map version. For ex: 23 -> 2,3 (V2,3)
     *
     * Range: 0..2550 (0..255 Version)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t can_map_version;
};

/**
 * Signals in message HV500_SetDriveEnable.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_drive_enable_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmd_drive_enable;
};

/**
 * Signals in message HV500_SetAcCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_ac_current_t {
    /**
     * Range: -10000..10000 (-1000..1000 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_ac_current;
};

/**
 * Signals in message HV500_SetBrakeCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_brake_current_t {
    /**
     * Range: 0..10000 (0..1000 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_brake_current;
};

/**
 * Signals in message HV500_SetERPM.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_erpm_t {
    /**
     * Range: -2147480000..2147480000 (-2147480000..2147480000 ERPM)
     * Scale: 1
     * Offset: 0
     */
    int32_t cmd_target_speed;
};

/**
 * Signals in message HV500_SetPosition.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_position_t {
    /**
     * Range: 0..3600 (0..360 degree)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_position;
};

/**
 * Signals in message HV500_SetRelCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_rel_current_t {
    /**
     * Range: -1000..1000 (-100..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_target_relative_current;
};

/**
 * Signals in message HV500_SetRelBrakeCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_rel_brake_current_t {
    /**
     * Range: 0..1000 (0..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_targe_relative_brake_current;
};

/**
 * Signals in message HV500_SetMaxAcCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_max_ac_current_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_ac_current;
};

/**
 * Signals in message HV500_SetMaxAcBrakeCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_ac_brake_current;
};

/**
 * Signals in message HV500_SetMaxDcCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_max_dc_current_t {
    /**
     * Range: 0..3500 (0..350 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_dc_current;
};

/**
 * Signals in message HV500_SetMaxDcBrakeCurrent.
 *
 * Node ID: 20
 *
 * All signal values are as on the CAN bus.
 */
struct hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_t {
    /**
     * Range: 0..3500 (0..350 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t cmd_max_dc_brake_current;
};

/**
 * Pack message HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_t *src_p,
    size_t size);

/**
 * Unpack message HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_unpack(
    struct hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_ERPM_DUTY_VOLTAGE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_init(struct hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_erpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_erpm_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_erpm_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_duty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_duty_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_duty_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_input_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_input_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_erpm_duty_voltage_actual_input_voltage_is_in_range(int16_t value);

/**
 * Pack message HV500_AC_DC_current.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_ac_dc_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_ac_dc_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_AC_DC_current.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_ac_dc_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_ac_dc_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_AC_DC_current.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_ac_dc_current_init(struct hv500_can2_map_v23_sid_hv500_ac_dc_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_ac_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_dc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_dc_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_ac_dc_current_actual_dc_current_is_in_range(int16_t value);

/**
 * Pack message HV500_Temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_temperatures_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message HV500_Temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_temperatures_unpack(
    struct hv500_can2_map_v23_sid_hv500_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_Temperatures.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_temperatures_init(struct hv500_can2_map_v23_sid_hv500_temperatures_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_controller_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_controller_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_controller_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_temperatures_actual_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_temperatures_actual_fault_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_temperatures_actual_fault_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_temperatures_actual_fault_code_is_in_range(uint8_t value);

/**
 * Pack message HV500_FOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_foc_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_foc_t *src_p,
    size_t size);

/**
 * Unpack message HV500_FOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_foc_unpack(
    struct hv500_can2_map_v23_sid_hv500_foc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_FOC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_foc_init(struct hv500_can2_map_v23_sid_hv500_foc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t hv500_can2_map_v23_sid_hv500_foc_actual_foc_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_foc_actual_foc_id_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_foc_actual_foc_id_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t hv500_can2_map_v23_sid_hv500_foc_actual_foc_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_foc_actual_foc_iq_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_foc_actual_foc_iq_is_in_range(int32_t value);

/**
 * Pack message HV500_MISC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_misc_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_misc_t *src_p,
    size_t size);

/**
 * Unpack message HV500_MISC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_misc_unpack(
    struct hv500_can2_map_v23_sid_hv500_misc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_MISC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_misc_init(struct hv500_can2_map_v23_sid_hv500_misc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t hv500_can2_map_v23_sid_hv500_misc_actual_throttle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_actual_throttle_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_actual_throttle_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t hv500_can2_map_v23_sid_hv500_misc_actual_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_actual_brake_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_actual_brake_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_output_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_output_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_output_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_output_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_output_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_output_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_output_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_output_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_output_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_output_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_output_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_output_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_input_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_input_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_input_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_input_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_input_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_input_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_input_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_input_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_input_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_digital_input_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_digital_input_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_digital_input_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_drive_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_drive_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_drive_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_motor_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_motor_temp_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_motor_temp_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_motor_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_motor_accel_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_motor_accel_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_input_voltage_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_input_voltage_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_input_voltage_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_igbt_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_igbt_temp_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_igbt_temp_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_igbt_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_igbt_accel_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_igbt_accel_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_drive_enable_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_drive_enable_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_drive_enable_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_dc_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_dc_current_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_dc_current_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_capacitor_temp_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_capacitor_temp_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_capacitor_temp_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_power_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_power_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_power_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_rpm_max_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_rpm_max_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_rpm_max_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_rpm_min_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_rpm_min_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_rpm_min_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_misc_can_map_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_misc_can_map_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_misc_can_map_version_is_in_range(uint8_t value);

/**
 * Pack message HV500_SetDriveEnable.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_drive_enable_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_drive_enable_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetDriveEnable.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_drive_enable_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_drive_enable_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetDriveEnable.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_drive_enable_init(struct hv500_can2_map_v23_sid_hv500_set_drive_enable_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t hv500_can2_map_v23_sid_hv500_set_drive_enable_cmd_drive_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_drive_enable_cmd_drive_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_drive_enable_cmd_drive_enable_is_in_range(uint8_t value);

/**
 * Pack message HV500_SetAcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_ac_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_ac_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetAcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_ac_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_ac_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetAcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_ac_current_init(struct hv500_can2_map_v23_sid_hv500_set_ac_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_ac_current_cmd_target_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_ac_current_cmd_target_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_ac_current_cmd_target_ac_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_brake_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_brake_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_brake_current_init(struct hv500_can2_map_v23_sid_hv500_set_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_brake_current_cmd_target_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_brake_current_cmd_target_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_brake_current_cmd_target_brake_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetERPM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_erpm_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_erpm_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetERPM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_erpm_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_erpm_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetERPM.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_erpm_init(struct hv500_can2_map_v23_sid_hv500_set_erpm_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t hv500_can2_map_v23_sid_hv500_set_erpm_cmd_target_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_erpm_cmd_target_speed_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_erpm_cmd_target_speed_is_in_range(int32_t value);

/**
 * Pack message HV500_SetPosition.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_position_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_position_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetPosition.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_position_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_position_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetPosition.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_position_init(struct hv500_can2_map_v23_sid_hv500_set_position_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_position_cmd_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_position_cmd_target_position_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_position_cmd_target_position_is_in_range(int16_t value);

/**
 * Pack message HV500_SetRelCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_rel_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetRelCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_rel_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetRelCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_current_init(struct hv500_can2_map_v23_sid_hv500_set_rel_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_rel_current_cmd_target_relative_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_rel_current_cmd_target_relative_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_rel_current_cmd_target_relative_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetRelBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_brake_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_rel_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetRelBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_brake_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_rel_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetRelBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_rel_brake_current_init(struct hv500_can2_map_v23_sid_hv500_set_rel_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_rel_brake_current_cmd_targe_relative_brake_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetMaxAcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_max_ac_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetMaxAcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_max_ac_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetMaxAcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_current_init(struct hv500_can2_map_v23_sid_hv500_set_max_ac_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_max_ac_current_cmd_max_ac_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_max_ac_current_cmd_max_ac_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_max_ac_current_cmd_max_ac_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetMaxAcBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetMaxAcBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetMaxAcBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_init(struct hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_max_ac_brake_current_cmd_max_ac_brake_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetMaxDcCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_max_dc_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetMaxDcCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_max_dc_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetMaxDcCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_current_init(struct hv500_can2_map_v23_sid_hv500_set_max_dc_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_max_dc_current_cmd_max_dc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_max_dc_current_cmd_max_dc_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_max_dc_current_cmd_max_dc_current_is_in_range(int16_t value);

/**
 * Pack message HV500_SetMaxDcBrakeCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_pack(
    uint8_t *dst_p,
    const struct hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_t *src_p,
    size_t size);

/**
 * Unpack message HV500_SetMaxDcBrakeCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_unpack(
    struct hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HV500_SetMaxDcBrakeCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_init(struct hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool hv500_can2_map_v23_sid_hv500_set_max_dc_brake_current_cmd_max_dc_brake_current_is_in_range(int16_t value);


#ifdef __cplusplus
}
#endif

#endif
