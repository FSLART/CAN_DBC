/**
 * @file fsg_dbc.h
 *
 * @brief This header file was generated by cantools version 40.2.3 Sat Jul 26 00:48:02 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef FSG_DBC_H
#define FSG_DBC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_FRAME_ID (0x500u)
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)
#define FSG_DBC_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define FSG_DBC_ASF_VARS_FRAME_ID (0x511u)

/* Frame lengths in bytes. */
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_LENGTH (8u)
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_LENGTH (6u)
#define FSG_DBC_DV_SYSTEM_STATUS_LENGTH (5u)
#define FSG_DBC_ASF_VARS_LENGTH (8u)

/* Extended or standard frame types. */
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_IS_EXTENDED (0)
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)
#define FSG_DBC_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define FSG_DBC_ASF_VARS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_OFF_CHOICE (1u)
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_READY_CHOICE (2u)
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_DRIVING_CHOICE (3u)
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_EMERGENCY_CHOICE (4u)
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_FINISH_CHOICE (5u)

#define FSG_DBC_DV_SYSTEM_STATUS_ASB_EBS_STATE_ASB_EBS_STATE_DEACTIVATED_CHOICE (1u)
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_EBS_STATE_ASB_EBS_STATE_INITIAL_CHECKUP_PASSED_CHOICE (2u)
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_EBS_STATE_ASB_EBS_STATE_ACTIVATED__CHOICE (3u)

#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_ACCELERATION_CHOICE (1u)
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_SKIDPAD__CHOICE (2u)
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_TRACKDRIVE_CHOICE (3u)
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_BRAKETEST_CHOICE (4u)
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_INSPECTION__CHOICE (5u)
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_AMI_STATE_AUTOCROSS_CHOICE (6u)

#define FSG_DBC_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_ASB_REDUNDANCY_STATE_DEACTIVATED_CHOICE (1u)
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_ASB_REDUNDANCY_STATE_ENGAGED__CHOICE (2u)
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_ASB_REDUNDANCY_STATE_INITIAL_CHECKUP_PASSED_CHOICE (3u)

/* Frame Names. */
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_NAME "DV_Driving_dynamycs_1"
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_NAME "DV_driving_dynamics_2"
#define FSG_DBC_DV_SYSTEM_STATUS_NAME "DV_system_status"
#define FSG_DBC_ASF_VARS_NAME "ASF_VARS"

/* Signal Names. */
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_SPEED_ACTUAL_NAME "Speed_actual"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_SPEED_TARGET_NAME "Speed_target"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_STEERING_ANGLE_ACTUAL_NAME "Steering_angle_actual"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_STEERING_ANGLE_TARGET_NAME "Steering_angle_target"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_BRAKE_HYDR_ACTUA_NAME "Brake_hydr_actua"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_BRAKE_HYDR_TARGET_NAME "Brake_Hydr_target"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_MOTOR_MOMENT_ACTUAL_NAME "Motor_moment_actual"
#define FSG_DBC_DV_DRIVING_DYNAMYCS_1_MOTOR_MOMNET_TARGET_NAME "Motor_momnet_target"
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_ACCELERATION_LONGITUDINAL_NAME "Acceleration_longitudinal"
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_ACCELERATION_LATERAL_NAME "Acceleration_lateral"
#define FSG_DBC_DV_DRIVING_DYNAMICS_2_YAW_RATE_NAME "Yaw_rate"
#define FSG_DBC_DV_SYSTEM_STATUS_AS_STATUS_NAME "AS_status"
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_EBS_STATE_NAME "ASB_EBS_STATE"
#define FSG_DBC_DV_SYSTEM_STATUS_AMI_STATE_NAME "AMI_state"
#define FSG_DBC_DV_SYSTEM_STATUS_STEERING_STATE_NAME "Steering_state"
#define FSG_DBC_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_NAME "ASB_redundancy_state"
#define FSG_DBC_DV_SYSTEM_STATUS_LAP_COUNTER_NAME "Lap_counter"
#define FSG_DBC_DV_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "Cones_count_actual"
#define FSG_DBC_DV_SYSTEM_STATUS_CONES_COUNT_ALL_NAME "Cones_count_all"
#define FSG_DBC_ASF_VARS_EBS_PRESSURE_TANK_FRONT_NAME "EBS_pressure_tank_front"
#define FSG_DBC_ASF_VARS_EBS_PRESSURE_TANK_REAR_NAME "EBS_pressure_tank_rear"
#define FSG_DBC_ASF_VARS_BRAKE_PRESSURE_FRONT_NAME "Brake_pressure_front"
#define FSG_DBC_ASF_VARS_BRAKE_PRESSURE_REAR_NAME "Brake_pressure_rear"

/**
 * Signals in message DV_Driving_dynamycs_1.
 *
 * All signal values are as on the CAN bus.
 */
struct fsg_dbc_dv_driving_dynamycs_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_actua;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_momnet_target;
};

/**
 * Signals in message DV_driving_dynamics_2.
 *
 * All signal values are as on the CAN bus.
 */
struct fsg_dbc_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Signals in message DV_system_status.
 *
 * All signal values are as on the CAN bus.
 */
struct fsg_dbc_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_redundancy_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message ASF_VARS.
 *
 * All signal values are as on the CAN bus.
 */
struct fsg_dbc_asf_vars_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t ebs_pressure_tank_front;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t ebs_pressure_tank_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_front;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_rear;
};

/**
 * Pack message DV_Driving_dynamycs_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fsg_dbc_dv_driving_dynamycs_1_pack(
    uint8_t *dst_p,
    const struct fsg_dbc_dv_driving_dynamycs_1_t *src_p,
    size_t size);

/**
 * Unpack message DV_Driving_dynamycs_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fsg_dbc_dv_driving_dynamycs_1_unpack(
    struct fsg_dbc_dv_driving_dynamycs_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_Driving_dynamycs_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fsg_dbc_dv_driving_dynamycs_1_init(struct fsg_dbc_dv_driving_dynamycs_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_driving_dynamycs_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_driving_dynamycs_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t fsg_dbc_dv_driving_dynamycs_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t fsg_dbc_dv_driving_dynamycs_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_driving_dynamycs_1_brake_hydr_actua_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_brake_hydr_actua_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_brake_hydr_actua_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_driving_dynamycs_1_brake_hydr_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_brake_hydr_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_brake_hydr_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t fsg_dbc_dv_driving_dynamycs_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t fsg_dbc_dv_driving_dynamycs_1_motor_momnet_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamycs_1_motor_momnet_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamycs_1_motor_momnet_target_is_in_range(int8_t value);

/**
 * Pack message DV_driving_dynamics_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fsg_dbc_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct fsg_dbc_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message DV_driving_dynamics_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fsg_dbc_dv_driving_dynamics_2_unpack(
    struct fsg_dbc_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_driving_dynamics_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fsg_dbc_dv_driving_dynamics_2_init(struct fsg_dbc_dv_driving_dynamics_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fsg_dbc_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fsg_dbc_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fsg_dbc_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_driving_dynamics_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value);

/**
 * Pack message DV_system_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fsg_dbc_dv_system_status_pack(
    uint8_t *dst_p,
    const struct fsg_dbc_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message DV_system_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fsg_dbc_dv_system_status_unpack(
    struct fsg_dbc_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_system_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fsg_dbc_dv_system_status_init(struct fsg_dbc_dv_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_as_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_as_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_as_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_asb_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_asb_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_asb_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_asb_redundancy_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_asb_redundancy_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_asb_redundancy_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t fsg_dbc_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message ASF_VARS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fsg_dbc_asf_vars_pack(
    uint8_t *dst_p,
    const struct fsg_dbc_asf_vars_t *src_p,
    size_t size);

/**
 * Unpack message ASF_VARS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fsg_dbc_asf_vars_unpack(
    struct fsg_dbc_asf_vars_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ASF_VARS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fsg_dbc_asf_vars_init(struct fsg_dbc_asf_vars_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_asf_vars_ebs_pressure_tank_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_asf_vars_ebs_pressure_tank_front_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_asf_vars_ebs_pressure_tank_front_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_asf_vars_ebs_pressure_tank_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_asf_vars_ebs_pressure_tank_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_asf_vars_ebs_pressure_tank_rear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_asf_vars_brake_pressure_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_asf_vars_brake_pressure_front_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_asf_vars_brake_pressure_front_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fsg_dbc_asf_vars_brake_pressure_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fsg_dbc_asf_vars_brake_pressure_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fsg_dbc_asf_vars_brake_pressure_rear_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
